{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About The Platform for Oncogenomic Reporting and Interpretation (PORI) is an open source collection of software designed to support scaleable precision oncology. The platform has two main components: a graph knowledgebase ( GraphKB ) and an integrated pipeline reporting application ( IPR ). This site contains central documentation for the platform as well as setup and installation instructions. Demo A live demo of this is found at: pori-demo.bcgsc.ca . This demo was deployed via docker-compose. See the install section for instructions on setting up and deploying a new instance of PORI. Citation A pre-print of the related manuscript can be found at biorxiv .","title":"Home"},{"location":"#about","text":"The Platform for Oncogenomic Reporting and Interpretation (PORI) is an open source collection of software designed to support scaleable precision oncology. The platform has two main components: a graph knowledgebase ( GraphKB ) and an integrated pipeline reporting application ( IPR ). This site contains central documentation for the platform as well as setup and installation instructions.","title":"About"},{"location":"#demo","text":"A live demo of this is found at: pori-demo.bcgsc.ca . This demo was deployed via docker-compose. See the install section for instructions on setting up and deploying a new instance of PORI.","title":"Demo"},{"location":"#citation","text":"A pre-print of the related manuscript can be found at biorxiv .","title":"Citation"},{"location":"faq/","text":"FAQ How does Variant Annotation Work? Variants are annotated using the GraphKB Python Adaptor via the GraphKB REST API. In general this consists of the following steps Parse HGVS-like notation 1 Disambiguate via ontologies (gene name, variant type, etc.) Pull matching variant records Refine matches base on position information 1 Follows inferences (ex. g. -> p.) Pull statements for these variant records This allows an input like KRAS:p.G12D to match to all eqiuvalent forms of this variant. For example, in the demo database it would result in the following matches How do I cite PORI? Please cite the following pre-print Reisle, et. al. 2021 . How Can I Migrate Our Existing KB to GraphKB? The simplest way to do this is using the API. THere are a number of examples of loader/migration scripts in the loaders project which can be used as examples as well as instructions on best practices for adding or including your own. If you would like a new loader for a public/popular resource, please make a ticket/issue on this github space Is there a Licensing Requirement for PORI Software? No. PORI is fully open source. The entire platform is released under a GPL-3 open source license. Is there a Licensing Requirement for PORI Data? Data is loaded and added externally by the users themselves and therefore there is no licensing requirement. We do provided loading scripts for some externally licensed content, but it is left up to the user to arrange and a license agreement for these sources if they would like to use them. By default the loaders only load the open data. How Can I Get Involved? We welcome and encourage community contributions! If you have a feature request, bug report, or question please feel free to submit an issue to our GitHub page. If you are not sure which repository to submit the issue to, use this main one by default and we will move or direct the issue as required. If you are a developer and would like to directly add and work on features, please submit a ticket for any new features and indicate that you would like to complete it or comment on an existing ticket. Following discussion with the main developers you should fork the repository and then submit a pull request from your forked version to the main repository. How Can I Try This Out? We have created a demo version of PORI for users to test without having to set anything up. Please see the IPR and GraphKB demos here Only applicable to postional variants, these steps are skipped when matching category variants. \u21a9 \u21a9","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#how-does-variant-annotation-work","text":"Variants are annotated using the GraphKB Python Adaptor via the GraphKB REST API. In general this consists of the following steps Parse HGVS-like notation 1 Disambiguate via ontologies (gene name, variant type, etc.) Pull matching variant records Refine matches base on position information 1 Follows inferences (ex. g. -> p.) Pull statements for these variant records This allows an input like KRAS:p.G12D to match to all eqiuvalent forms of this variant. For example, in the demo database it would result in the following matches","title":"How does Variant Annotation Work?"},{"location":"faq/#how-do-i-cite-pori","text":"Please cite the following pre-print Reisle, et. al. 2021 .","title":"How do I cite PORI?"},{"location":"faq/#how-can-i-migrate-our-existing-kb-to-graphkb","text":"The simplest way to do this is using the API. THere are a number of examples of loader/migration scripts in the loaders project which can be used as examples as well as instructions on best practices for adding or including your own. If you would like a new loader for a public/popular resource, please make a ticket/issue on this github space","title":"How Can I Migrate Our Existing KB to GraphKB?"},{"location":"faq/#is-there-a-licensing-requirement-for-pori-software","text":"No. PORI is fully open source. The entire platform is released under a GPL-3 open source license.","title":"Is there a Licensing Requirement for PORI Software?"},{"location":"faq/#is-there-a-licensing-requirement-for-pori-data","text":"Data is loaded and added externally by the users themselves and therefore there is no licensing requirement. We do provided loading scripts for some externally licensed content, but it is left up to the user to arrange and a license agreement for these sources if they would like to use them. By default the loaders only load the open data.","title":"Is there a Licensing Requirement for PORI Data?"},{"location":"faq/#how-can-i-get-involved","text":"We welcome and encourage community contributions! If you have a feature request, bug report, or question please feel free to submit an issue to our GitHub page. If you are not sure which repository to submit the issue to, use this main one by default and we will move or direct the issue as required. If you are a developer and would like to directly add and work on features, please submit a ticket for any new features and indicate that you would like to complete it or comment on an existing ticket. Following discussion with the main developers you should fork the repository and then submit a pull request from your forked version to the main repository.","title":"How Can I Get Involved?"},{"location":"faq/#how-can-i-try-this-out","text":"We have created a demo version of PORI for users to test without having to set anything up. Please see the IPR and GraphKB demos here Only applicable to postional variants, these steps are skipped when matching category variants. \u21a9 \u21a9","title":"How Can I Try This Out?"},{"location":"install/","text":"Install with Docker Since PORI is a production-ready, institution-level, scaleable platform, the simplest way to get the entire platform up and running from scratch is using docker. Most of the servers are auto-started together with docker-compose but the keycloak container must be started and configured on its own first. The instructions below set up the platform with HTTPS and then use a reverse proxy to pick up the ports. This way you can omit the proxy step and run the platform with http when initialling setting up and testing. Start by cloning this repository which contains the default docker compose config (docker-compose.yml) git clone https://github.com/bcgsc/pori.git cd pori Start the Authentication Server Before any of the other systems can be set up you will need to start the authenication server. By default, PORI authenticates against an instance of KeyCloak. For convenience we have provided a docker container with a default configuration of keycloak. This is the authentication server used by our demo instance . If your institution already has a keycloak server then we have more [detailed instuctions on setting up through the GUI][https://github.com/bcgsc/pori/blob/master/docs/auth.md] in this repository. docker run \\ -e KEYCLOAK_USER = admin \\ -e KEYCLOAK_PASSWORD = <PASSWORD> \\ -e KEYCLOAK_FRONTEND_URL = <URL> \\ -p 8443 :8334 \\ -p 8888 :8080 \\ -d \\ --mount type = bind,source = /etc/ssl/certs/current,target = /etc/x509/https,readonly \\ bcgsc/pori-auth:latest For the demo server (excluding password) this looked like docker run \\ -e KEYCLOAK_USER = admin \\ -e KEYCLOAK_PASSWORD = $DEMO_KC_ADMIN \\ -e KEYCLOAK_FRONTEND_URL = https://pori-demo.bcgsc.ca/auth \\ -p 8443 :8334 \\ -p 8888 :8080 \\ -d \\ --mount type = bind,source = /etc/ssl/certs/current,target = /etc/x509/https,readonly \\ bcgsc/pori-auth:latest Check that the docker container has started docker ps You should see something like this CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 16ff3826c976 bcgsc/pori-auth:latest \"/opt/jboss/tools/do\u2026\" About a minute ago Up About a minute 8443/tcp, 0.0.0.0:8888->8080/tcp strange_chaum After the container is started you can go to the admin console GUI to add a users and download the realm's public key file. This must be done prior to starting the other containers. The public key file will need to be passed to the GraphKB API container at run time. Copy it from the Realms > Keys page which should look something like below For the purposes of this example we have saved it as keys/keycloak.key and we will mount the keys directory to the api container in the next step. The content of the file should look something like this -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAoteEI/Iu923I4Zqt8prxIx3ljGEecnrI+sWjo4U3n14n/nY5NpfCiA+Pg1WQTQKsBHX5/sIm+Fn5FJpcpBzz8/5uEQJyPEOEezEuiP/yYjVbg4S25reOaQNRfsw7yZvdgrMySy3MrfjWw+luLa6Nt4AvZ6ywOqE8Q4SZgVxGQg07acenpR6U+bkNj3AxFFEeYqiktfKPI7iLykVBz/hXANnrs9zd036vcgAYa2IxmWpo38ZOksKTgYL5IDG1zZ5S6VM43mD7hE8jG+kCVbiNVlrYFTXxIkRmaOO9krykPoLux7tjXAFEfTwMji++HQjc724FigsnoJ3xZkUzCSzkTQIDAQAB -----END PUBLIC KEY----- Both the IPR and GraphKB API containers will use this ./keys folder, binding it into the container at run time (See volumes section of docker compose file). You will also want to add a couple of users to make things simpler to test. If you use the non-default demo passwords (RECCOMMENDED!) you will need to change the corresponding fields in the docker compose file. The names of these users can also be changed but it will require also adding them to the application databases. Name Default in DB Purpose graphkb_importer GraphKB This is the default user that is created when the new GraphKB DB is created. It is an admin user that can be used to add new users or import content ipr_graphkb_link GraphKB This is the user used by IPR to pull data from GraphKB iprdemo IPR This is an admin user in the IPR demo db graphkb_admin GraphKB Admin user for managing content/users in the GraphKB web interface Add the above users to keycloak with the IPR and GraphKB roles. Docker-Compose Now you are ready to start the other services. This will use the docker-compose.yml file to configure the network. First create empty directories to mount the database data, this will ensure the databases are not lost when you stop/restart the container mkdir -p databases/ { postgres,orientdb } / { backup,data } Next, use docker-compose to start the DB, API, and client servers. The paths/URLs in the docker-compose.yml file should be adjusted to match your deployment. In our demo deployment we have a proxy pass set up from the configured ports to handle the https layer docker-compose up This will start the following services Postgres db server for IPR with a default db dump OrientDB server for GraphKB with an empty default db GraphKB API server (nodejs) IPR API server (nodejs) GraphKB client server (nginx) IPR client server (nginx) Once the platform is live you can populate the new GraphKB instance with external content using the loaders.","title":"Install with Docker"},{"location":"install/#install-with-docker","text":"Since PORI is a production-ready, institution-level, scaleable platform, the simplest way to get the entire platform up and running from scratch is using docker. Most of the servers are auto-started together with docker-compose but the keycloak container must be started and configured on its own first. The instructions below set up the platform with HTTPS and then use a reverse proxy to pick up the ports. This way you can omit the proxy step and run the platform with http when initialling setting up and testing. Start by cloning this repository which contains the default docker compose config (docker-compose.yml) git clone https://github.com/bcgsc/pori.git cd pori","title":"Install with Docker"},{"location":"install/#start-the-authentication-server","text":"Before any of the other systems can be set up you will need to start the authenication server. By default, PORI authenticates against an instance of KeyCloak. For convenience we have provided a docker container with a default configuration of keycloak. This is the authentication server used by our demo instance . If your institution already has a keycloak server then we have more [detailed instuctions on setting up through the GUI][https://github.com/bcgsc/pori/blob/master/docs/auth.md] in this repository. docker run \\ -e KEYCLOAK_USER = admin \\ -e KEYCLOAK_PASSWORD = <PASSWORD> \\ -e KEYCLOAK_FRONTEND_URL = <URL> \\ -p 8443 :8334 \\ -p 8888 :8080 \\ -d \\ --mount type = bind,source = /etc/ssl/certs/current,target = /etc/x509/https,readonly \\ bcgsc/pori-auth:latest For the demo server (excluding password) this looked like docker run \\ -e KEYCLOAK_USER = admin \\ -e KEYCLOAK_PASSWORD = $DEMO_KC_ADMIN \\ -e KEYCLOAK_FRONTEND_URL = https://pori-demo.bcgsc.ca/auth \\ -p 8443 :8334 \\ -p 8888 :8080 \\ -d \\ --mount type = bind,source = /etc/ssl/certs/current,target = /etc/x509/https,readonly \\ bcgsc/pori-auth:latest Check that the docker container has started docker ps You should see something like this CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 16ff3826c976 bcgsc/pori-auth:latest \"/opt/jboss/tools/do\u2026\" About a minute ago Up About a minute 8443/tcp, 0.0.0.0:8888->8080/tcp strange_chaum After the container is started you can go to the admin console GUI to add a users and download the realm's public key file. This must be done prior to starting the other containers. The public key file will need to be passed to the GraphKB API container at run time. Copy it from the Realms > Keys page which should look something like below For the purposes of this example we have saved it as keys/keycloak.key and we will mount the keys directory to the api container in the next step. The content of the file should look something like this -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAoteEI/Iu923I4Zqt8prxIx3ljGEecnrI+sWjo4U3n14n/nY5NpfCiA+Pg1WQTQKsBHX5/sIm+Fn5FJpcpBzz8/5uEQJyPEOEezEuiP/yYjVbg4S25reOaQNRfsw7yZvdgrMySy3MrfjWw+luLa6Nt4AvZ6ywOqE8Q4SZgVxGQg07acenpR6U+bkNj3AxFFEeYqiktfKPI7iLykVBz/hXANnrs9zd036vcgAYa2IxmWpo38ZOksKTgYL5IDG1zZ5S6VM43mD7hE8jG+kCVbiNVlrYFTXxIkRmaOO9krykPoLux7tjXAFEfTwMji++HQjc724FigsnoJ3xZkUzCSzkTQIDAQAB -----END PUBLIC KEY----- Both the IPR and GraphKB API containers will use this ./keys folder, binding it into the container at run time (See volumes section of docker compose file). You will also want to add a couple of users to make things simpler to test. If you use the non-default demo passwords (RECCOMMENDED!) you will need to change the corresponding fields in the docker compose file. The names of these users can also be changed but it will require also adding them to the application databases. Name Default in DB Purpose graphkb_importer GraphKB This is the default user that is created when the new GraphKB DB is created. It is an admin user that can be used to add new users or import content ipr_graphkb_link GraphKB This is the user used by IPR to pull data from GraphKB iprdemo IPR This is an admin user in the IPR demo db graphkb_admin GraphKB Admin user for managing content/users in the GraphKB web interface Add the above users to keycloak with the IPR and GraphKB roles.","title":"Start the Authentication Server"},{"location":"install/#docker-compose","text":"Now you are ready to start the other services. This will use the docker-compose.yml file to configure the network. First create empty directories to mount the database data, this will ensure the databases are not lost when you stop/restart the container mkdir -p databases/ { postgres,orientdb } / { backup,data } Next, use docker-compose to start the DB, API, and client servers. The paths/URLs in the docker-compose.yml file should be adjusted to match your deployment. In our demo deployment we have a proxy pass set up from the configured ports to handle the https layer docker-compose up This will start the following services Postgres db server for IPR with a default db dump OrientDB server for GraphKB with an empty default db GraphKB API server (nodejs) IPR API server (nodejs) GraphKB client server (nginx) IPR client server (nginx) Once the platform is live you can populate the new GraphKB instance with external content using the loaders.","title":"Docker-Compose"},{"location":"repos/","text":"All PORI Repositories The platform has two main components: a graph knowledge base ( GraphKB ), and a reporting application ( IPR ). However these are modularized across several repositories listed below. GraphKB API GraphKB REST API and Graph Database. The GraphKB database is implemented using OrientDB . It is a graph database which is used to store variants, ontologies, and the relevance of this terms and variants. The KB uses strict controlled vocabulary to provide a parseable and machine-readable interface for other applications to build on. The API is a REST API built on node/express. GraphKB client The GraphKB client is the front-end web client for the GraphKB project. It is built using React.js and webpack. The client is used to explore and manage content within GraphKB. GraphKB Python Adaptor Python adapter package for querying the GraphKB API. See the related user manual for instructions on incorporating this into custom scripts. IPR API The Integrated Pipeline Reports (IPR) REST API manages data access to the IPR database. The API is responsible for storing and server all data for reports. IPR client The IPR client is front-end web application which consumes data from the IPR API. The primary function is the production and management of genomic reports. IPR Python Adaptor Python adapter for generating reports uploaded to the IPR API. This python tool takes in variant inputs as tab-delimited files and annotates them using GraphKB. The resulting output is uploaded to IPR as a report. Additional report content such as images and metadata can be passed to be included in the report upload. See the related user manual for additional information. GraphKB Data Loaders GraphKB loaders is responsible for all data import into GraphKB. Automatic Import modules are provided for a variety of external ontologies and knowledgebases such as: Ensembl, Entrez Genes, RefSeq, HGNC, Disease Ontology, NCI Thesaurus, CIViC, DoCM, etc. GraphKB Parser A package for parsing and recreating HGVS-like variant notation used in GraphKB. This is used by both the API and Client applications. Try it out online with RunKit GraphKB Schema The GraphKB Schema package defines the vertex and edge classes in the DB. It is used as a dependency of both the API and client applications.","title":"All PORI Repositories"},{"location":"repos/#all-pori-repositories","text":"The platform has two main components: a graph knowledge base ( GraphKB ), and a reporting application ( IPR ). However these are modularized across several repositories listed below.","title":"All PORI Repositories"},{"location":"repos/#graphkb-api","text":"GraphKB REST API and Graph Database. The GraphKB database is implemented using OrientDB . It is a graph database which is used to store variants, ontologies, and the relevance of this terms and variants. The KB uses strict controlled vocabulary to provide a parseable and machine-readable interface for other applications to build on. The API is a REST API built on node/express.","title":"GraphKB API"},{"location":"repos/#graphkb-client","text":"The GraphKB client is the front-end web client for the GraphKB project. It is built using React.js and webpack. The client is used to explore and manage content within GraphKB.","title":"GraphKB client"},{"location":"repos/#graphkb-python-adaptor","text":"Python adapter package for querying the GraphKB API. See the related user manual for instructions on incorporating this into custom scripts.","title":"GraphKB Python Adaptor"},{"location":"repos/#ipr-api","text":"The Integrated Pipeline Reports (IPR) REST API manages data access to the IPR database. The API is responsible for storing and server all data for reports.","title":"IPR API"},{"location":"repos/#ipr-client","text":"The IPR client is front-end web application which consumes data from the IPR API. The primary function is the production and management of genomic reports.","title":"IPR client"},{"location":"repos/#ipr-python-adaptor","text":"Python adapter for generating reports uploaded to the IPR API. This python tool takes in variant inputs as tab-delimited files and annotates them using GraphKB. The resulting output is uploaded to IPR as a report. Additional report content such as images and metadata can be passed to be included in the report upload. See the related user manual for additional information.","title":"IPR Python Adaptor"},{"location":"repos/#graphkb-data-loaders","text":"GraphKB loaders is responsible for all data import into GraphKB. Automatic Import modules are provided for a variety of external ontologies and knowledgebases such as: Ensembl, Entrez Genes, RefSeq, HGNC, Disease Ontology, NCI Thesaurus, CIViC, DoCM, etc.","title":"GraphKB Data Loaders"},{"location":"repos/#graphkb-parser","text":"A package for parsing and recreating HGVS-like variant notation used in GraphKB. This is used by both the API and Client applications. Try it out online with RunKit","title":"GraphKB Parser"},{"location":"repos/#graphkb-schema","text":"The GraphKB Schema package defines the vertex and edge classes in the DB. It is used as a dependency of both the API and client applications.","title":"GraphKB Schema"},{"location":"developer_reference/graphkb/__init__/","text":"graphkb DEFAULT_URL DEFAULT_URL = 'https://graphkb-api.bcgsc.ca/api' DEFAULT_LIMIT DEFAULT_LIMIT = 1000 QUERY_CACHE QUERY_CACHE : Dict [ Any , Any ] = {} class GraphKBConnection GraphKBConnection.request() Request wrapper to handle adding common headers and logging def request ( self , endpoint : str , method : str = 'GET' , ** kwargs ) -> Dict : Args endpoint ( str ): api endpoint, excluding the base uri method ( str ): the http method. Defaults to 'GET'. Returns Dict : the json response as a python dict GraphKBConnection.post() Convenience method for making post requests def post ( self , uri : str , data : Dict = {}, ** kwargs ) -> Dict : Args uri ( str ) data ( Dict ) Returns Dict GraphKBConnection.set_cache_data() Explicitly add a query to the cache def set_cache_data ( self , request_body : Dict , result : List [ Record ]) -> None : Args request_body ( Dict ) result (List[ Record ]) GraphKBConnection.query() Query GraphKB def query ( self , request_body : Dict = {}, paginate : bool = True , ignore_cache : bool = False , force_refresh : bool = False , limit : int = DEFAULT_LIMIT , ) -> List [ Record ]: Args request_body ( Dict ) paginate ( bool ) ignore_cache ( bool ) force_refresh ( bool ) limit ( int ) Returns List[ Record ] join_url() Join parts of a URL into a full URL def join_url ( base_url : str , * parts ) -> str : Args base_url ( str ) Returns str millis_interval() start and end are datetime instances def millis_interval ( start : datetime , end : datetime ) -> int : Args start ( datetime ) end ( datetime ) Returns int cache_key() create a cache key for a query request to GraphKB def cache_key ( request_body ): Args request_body","title":"graphkb"},{"location":"developer_reference/graphkb/__init__/#graphkb","text":"","title":"graphkb"},{"location":"developer_reference/graphkb/__init__/#default_url","text":"DEFAULT_URL = 'https://graphkb-api.bcgsc.ca/api'","title":"DEFAULT_URL"},{"location":"developer_reference/graphkb/__init__/#default_limit","text":"DEFAULT_LIMIT = 1000","title":"DEFAULT_LIMIT"},{"location":"developer_reference/graphkb/__init__/#query_cache","text":"QUERY_CACHE : Dict [ Any , Any ] = {}","title":"QUERY_CACHE"},{"location":"developer_reference/graphkb/__init__/#class-graphkbconnection","text":"","title":"class GraphKBConnection"},{"location":"developer_reference/graphkb/__init__/#graphkbconnectionrequest","text":"Request wrapper to handle adding common headers and logging def request ( self , endpoint : str , method : str = 'GET' , ** kwargs ) -> Dict : Args endpoint ( str ): api endpoint, excluding the base uri method ( str ): the http method. Defaults to 'GET'. Returns Dict : the json response as a python dict","title":"GraphKBConnection.request()"},{"location":"developer_reference/graphkb/__init__/#graphkbconnectionpost","text":"Convenience method for making post requests def post ( self , uri : str , data : Dict = {}, ** kwargs ) -> Dict : Args uri ( str ) data ( Dict ) Returns Dict","title":"GraphKBConnection.post()"},{"location":"developer_reference/graphkb/__init__/#graphkbconnectionset_cache_data","text":"Explicitly add a query to the cache def set_cache_data ( self , request_body : Dict , result : List [ Record ]) -> None : Args request_body ( Dict ) result (List[ Record ])","title":"GraphKBConnection.set_cache_data()"},{"location":"developer_reference/graphkb/__init__/#graphkbconnectionquery","text":"Query GraphKB def query ( self , request_body : Dict = {}, paginate : bool = True , ignore_cache : bool = False , force_refresh : bool = False , limit : int = DEFAULT_LIMIT , ) -> List [ Record ]: Args request_body ( Dict ) paginate ( bool ) ignore_cache ( bool ) force_refresh ( bool ) limit ( int ) Returns List[ Record ]","title":"GraphKBConnection.query()"},{"location":"developer_reference/graphkb/__init__/#join_url","text":"Join parts of a URL into a full URL def join_url ( base_url : str , * parts ) -> str : Args base_url ( str ) Returns str","title":"join_url()"},{"location":"developer_reference/graphkb/__init__/#millis_interval","text":"start and end are datetime instances def millis_interval ( start : datetime , end : datetime ) -> int : Args start ( datetime ) end ( datetime ) Returns int","title":"millis_interval()"},{"location":"developer_reference/graphkb/__init__/#cache_key","text":"create a cache key for a query request to GraphKB def cache_key ( request_body ): Args request_body","title":"cache_key()"},{"location":"developer_reference/graphkb/genes/","text":"graphkb.genes Methods for retrieving gene annotation lists from GraphKB ONCOKB_SOURCE_NAME ONCOKB_SOURCE_NAME = 'oncokb' ONCOGENE ONCOGENE = 'oncogenic' TUMOUR_SUPPRESSIVE TUMOUR_SUPPRESSIVE = 'tumour suppressive' FUSION_NAMES FUSION_NAMES = [ 'structural variant' , 'fusion' ] GENE_RETURN_PROPERTIES GENE_RETURN_PROPERTIES = [ 'name' , '@rid' , '@class' , 'sourceId' , 'sourceIdVersion' , 'source.name' , 'source.@rid' , 'displayName' , 'biotype' , 'deprecated' , ] get_oncokb_oncogenes() Gets the list of oncogenes stored in GraphKB derived from OncoKB def get_oncokb_oncogenes ( conn : GraphKBConnection ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object Returns List[ Ontology ]: gene (Feature) records get_oncokb_tumour_supressors() Gets the list of tumour supressor genes stored in GraphKB derived from OncoKB def get_oncokb_tumour_supressors ( conn : GraphKBConnection ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object Returns List[ Ontology ]: gene (Feature) records get_genes_from_variant_types() Retrieve a list of Genes which are found in variants on the given types def get_genes_from_variant_types ( conn : GraphKBConnection , types : List [ str ], source_record_ids : List [ str ] = [], ignore_cache : bool = False , ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object types ( List[str] ): list of names of variant types source_record_ids ( List[str] ): list of sources ids to filter genes by ignore_cache ( bool ) Returns List[ Ontology ]: gene (Feature) records","title":"graphkb.genes"},{"location":"developer_reference/graphkb/genes/#graphkbgenes","text":"Methods for retrieving gene annotation lists from GraphKB","title":"graphkb.genes"},{"location":"developer_reference/graphkb/genes/#oncokb_source_name","text":"ONCOKB_SOURCE_NAME = 'oncokb'","title":"ONCOKB_SOURCE_NAME"},{"location":"developer_reference/graphkb/genes/#oncogene","text":"ONCOGENE = 'oncogenic'","title":"ONCOGENE"},{"location":"developer_reference/graphkb/genes/#tumour_suppressive","text":"TUMOUR_SUPPRESSIVE = 'tumour suppressive'","title":"TUMOUR_SUPPRESSIVE"},{"location":"developer_reference/graphkb/genes/#fusion_names","text":"FUSION_NAMES = [ 'structural variant' , 'fusion' ]","title":"FUSION_NAMES"},{"location":"developer_reference/graphkb/genes/#gene_return_properties","text":"GENE_RETURN_PROPERTIES = [ 'name' , '@rid' , '@class' , 'sourceId' , 'sourceIdVersion' , 'source.name' , 'source.@rid' , 'displayName' , 'biotype' , 'deprecated' , ]","title":"GENE_RETURN_PROPERTIES"},{"location":"developer_reference/graphkb/genes/#get_oncokb_oncogenes","text":"Gets the list of oncogenes stored in GraphKB derived from OncoKB def get_oncokb_oncogenes ( conn : GraphKBConnection ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object Returns List[ Ontology ]: gene (Feature) records","title":"get_oncokb_oncogenes()"},{"location":"developer_reference/graphkb/genes/#get_oncokb_tumour_supressors","text":"Gets the list of tumour supressor genes stored in GraphKB derived from OncoKB def get_oncokb_tumour_supressors ( conn : GraphKBConnection ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object Returns List[ Ontology ]: gene (Feature) records","title":"get_oncokb_tumour_supressors()"},{"location":"developer_reference/graphkb/genes/#get_genes_from_variant_types","text":"Retrieve a list of Genes which are found in variants on the given types def get_genes_from_variant_types ( conn : GraphKBConnection , types : List [ str ], source_record_ids : List [ str ] = [], ignore_cache : bool = False , ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object types ( List[str] ): list of names of variant types source_record_ids ( List[str] ): list of sources ids to filter genes by ignore_cache ( bool ) Returns List[ Ontology ]: gene (Feature) records","title":"get_genes_from_variant_types()"},{"location":"developer_reference/graphkb/match/","text":"graphkb.match Functions which return Variants from GraphKB which match some input variant definition INPUT_COPY_CATEGORIES INPUT_COPY_CATEGORIES = IterableNamespace ( AMP = 'amplification' , ANY_GAIN = 'copy gain' , ANY_LOSS = 'copy loss' , DEEP = 'deep deletion' , GAIN = 'low level copy gain' , LOSS = 'shallow deletion' , ) INPUT_EXPRESSION_CATEGORIES INPUT_EXPRESSION_CATEGORIES = IterableNamespace ( UP = 'increased expression' , DOWN = 'reduced expression' ) AMBIGUOUS_AA AMBIGUOUS_AA = [ 'x' , '?' , 'X' ] VARIANT_RETURN_PROPERTIES VARIANT_RETURN_PROPERTIES = ( BASE_RETURN_PROPERTIES + [ f 'type. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'reference1. { p } ' for p in GENE_RETURN_PROPERTIES ] + [ f 'reference2. { p } ' for p in GENE_RETURN_PROPERTIES ] + [ 'zygosity' , 'germline' , 'displayName' ] POS_VARIANT_RETURN_PROPERTIES POS_VARIANT_RETURN_PROPERTIES = VARIANT_RETURN_PROPERTIES + [ 'break1Start' , 'break1End' , 'break2Start' , 'break2End' , 'break1Repr' , 'break2Repr' , 'refSeq' , 'untemplatedSeq' , 'untemplatedSeqSize' , 'truncation' , 'assembly' , FEATURES_CACHE FEATURES_CACHE : Set [ str ] = set () get_equivalent_features() Match an equivalent list of features given some input feature name (or ID) def get_equivalent_features ( conn : GraphKBConnection , gene_name : str , ignore_cache : bool = False , is_source_id : bool = False , source : str = '' , source_id_version : str = '' , ) -> List [ Ontology ]: Args conn ( GraphKBConnection ) gene_name ( str ): the gene name to search features by ignore_cache ( bool ): bypass the cache to always force a new request is_source_id ( bool ): treat the gene_name as the gene ID from the source database (ex. ENSG001) source ( str ): the name of the source database the gene definition is from (ex. ensembl) source_id_version ( str ): the version of the source_id Returns List[ Ontology ]: equivalent feature records Examples get_equivalent_features ( conn , 'KRAS' ) get_equivalent_features ( conn , 'ENSG001' , source = 'ensembl' , is_source_id = True ) get_equivalent_features ( conn , 'ENSG001' , source = 'ensembl' , source_id_version = '1' ) get_equivalent_features ( conn , '#3:44' ) cache_missing_features() Create a cache of features that exist to avoid repeatedly querying for missing features def cache_missing_features ( conn : GraphKBConnection ) -> None : Args conn ( GraphKBConnection ) match_category_variant() Returns a list of variants matching the input variant def match_category_variant ( conn : GraphKBConnection , gene_name : str , category : str , root_exclude_term : str = '' , gene_source : str = '' , gene_is_source_id : bool = False , ignore_cache : bool = False , ) -> List [ Variant ]: Args conn ( GraphKBConnection ): the graphkb connection object gene_name ( str ): the name of the gene the variant is in reference to category ( str ): the variant category (ex. copy loss) root_exclude_term ( str ) gene_source ( str ): The source database the gene is defined by (ex. ensembl) gene_is_source_id ( bool ): Indicates the gene name(s) input should be treated as sourceIds not names ignore_cache ( bool ) Returns List[ Variant ]: List of variant records from GraphKB which match the input Raises FeatureNotFoundError : The gene could not be found in GraphKB match_copy_variant() Returns a list of variants matching the input variant def match_copy_variant ( conn : GraphKBConnection , gene_name : str , category : str , drop_homozygous : bool = False , ** kwargs ) -> List [ Variant ]: Args conn ( GraphKBConnection ): the graphkb connection object gene_name ( str ): the name of the gene the variant is in reference to category ( str ): the variant category (ex. copy loss) drop_homozygous ( bool ): Drop homozygous matches from the result when true Returns List[ Variant ]: List of variant records from GraphKB which match the input Raises ValueError : The input copy category is not recognized positions_overlap() Check if 2 Position records from GraphKB indicate an overlap def positions_overlap ( pos_record : BasicPosition , range_start : BasicPosition , range_end : Optional [ BasicPosition ] = None ) -> bool : Args pos_record ( BasicPosition ): the record to compare range_start ( BasicPosition ): the position record indicating the start of an uncertainty range range_end (Optional[ BasicPosition ]): the position record indicating the end of an uncertainty range Returns bool : True if the positions overlap Raises NotImplementedError : if a cytoband type position is given Note null values indicate not-specified or any compare_positional_variants() Compare 2 variant records from GraphKB to determine if they are equivalent def compare_positional_variants ( variant : Union [ PositionalVariant , ParsedVariant ], reference_variant : Union [ PositionalVariant , ParsedVariant ], ) -> bool : Args variant (Union[ PositionalVariant , ParsedVariant ]): the input variant reference_variant (Union[ PositionalVariant , ParsedVariant ]): the reference (matched) variant record Returns bool : True if the records are equivalent match_positional_variant() Given the HGVS+ representation of some positional variant, parse it and match it to annotations in GraphKB def match_positional_variant ( conn : GraphKBConnection , variant_string : str , reference1 : Optional [ str ] = None , reference2 : Optional [ str ] = None , gene_is_source_id : bool = False , gene_source : str = '' , ignore_cache : bool = False , ) -> List [ Variant ]: Args conn ( GraphKBConnection ) variant_string ( str ): the HGVS+ annotation string reference1 ( Optional[str] ): Explicitly specify the first reference link record (gene1) reference2 ( Optional[str] ): Explicitly specify the second reference link record (gene2) gene_is_source_id ( bool ): Indicates the gene name(s) input should be treated as sourceIds not names gene_source ( str ): The source database the gene is defined by (ex. ensembl) ignore_cache ( bool ) Returns List[ Variant ]: A list of matched statement records Raises NotImplementedError : thrown for uncertain position input (ranges) FeatureNotFoundError : One of the genes does not exist in GraphKB ValueError : the gene names were given both in the variant_string and explicitly Examples match_positional_variant ( conn , '(EWSR1,FLI1):fusion(e.1,e.2)' ) match_positional_variant ( conn , 'fusion(e.1,e.2)' , 'EWSR1' , 'FLI1' ) match_positional_variant ( conn , 'fusion(e.1,e.2)' , '#3:4' , '#4:5' ) match_positional_variant ( conn , 'fusion(e.1,e.2)' , '123' , '456' , gene_is_source_id = True , gene_source = 'entrez gene' ) match_positional_variant ( conn , 'KRAS:p.G12D' ) match_positional_variant ( conn , 'p.G12D' , 'KRAS' )","title":"graphkb.match"},{"location":"developer_reference/graphkb/match/#graphkbmatch","text":"Functions which return Variants from GraphKB which match some input variant definition","title":"graphkb.match"},{"location":"developer_reference/graphkb/match/#input_copy_categories","text":"INPUT_COPY_CATEGORIES = IterableNamespace ( AMP = 'amplification' , ANY_GAIN = 'copy gain' , ANY_LOSS = 'copy loss' , DEEP = 'deep deletion' , GAIN = 'low level copy gain' , LOSS = 'shallow deletion' , )","title":"INPUT_COPY_CATEGORIES"},{"location":"developer_reference/graphkb/match/#input_expression_categories","text":"INPUT_EXPRESSION_CATEGORIES = IterableNamespace ( UP = 'increased expression' , DOWN = 'reduced expression' )","title":"INPUT_EXPRESSION_CATEGORIES"},{"location":"developer_reference/graphkb/match/#ambiguous_aa","text":"AMBIGUOUS_AA = [ 'x' , '?' , 'X' ]","title":"AMBIGUOUS_AA"},{"location":"developer_reference/graphkb/match/#variant_return_properties","text":"VARIANT_RETURN_PROPERTIES = ( BASE_RETURN_PROPERTIES + [ f 'type. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'reference1. { p } ' for p in GENE_RETURN_PROPERTIES ] + [ f 'reference2. { p } ' for p in GENE_RETURN_PROPERTIES ] + [ 'zygosity' , 'germline' , 'displayName' ]","title":"VARIANT_RETURN_PROPERTIES"},{"location":"developer_reference/graphkb/match/#pos_variant_return_properties","text":"POS_VARIANT_RETURN_PROPERTIES = VARIANT_RETURN_PROPERTIES + [ 'break1Start' , 'break1End' , 'break2Start' , 'break2End' , 'break1Repr' , 'break2Repr' , 'refSeq' , 'untemplatedSeq' , 'untemplatedSeqSize' , 'truncation' , 'assembly' ,","title":"POS_VARIANT_RETURN_PROPERTIES"},{"location":"developer_reference/graphkb/match/#features_cache","text":"FEATURES_CACHE : Set [ str ] = set ()","title":"FEATURES_CACHE"},{"location":"developer_reference/graphkb/match/#get_equivalent_features","text":"Match an equivalent list of features given some input feature name (or ID) def get_equivalent_features ( conn : GraphKBConnection , gene_name : str , ignore_cache : bool = False , is_source_id : bool = False , source : str = '' , source_id_version : str = '' , ) -> List [ Ontology ]: Args conn ( GraphKBConnection ) gene_name ( str ): the gene name to search features by ignore_cache ( bool ): bypass the cache to always force a new request is_source_id ( bool ): treat the gene_name as the gene ID from the source database (ex. ENSG001) source ( str ): the name of the source database the gene definition is from (ex. ensembl) source_id_version ( str ): the version of the source_id Returns List[ Ontology ]: equivalent feature records Examples get_equivalent_features ( conn , 'KRAS' ) get_equivalent_features ( conn , 'ENSG001' , source = 'ensembl' , is_source_id = True ) get_equivalent_features ( conn , 'ENSG001' , source = 'ensembl' , source_id_version = '1' ) get_equivalent_features ( conn , '#3:44' )","title":"get_equivalent_features()"},{"location":"developer_reference/graphkb/match/#cache_missing_features","text":"Create a cache of features that exist to avoid repeatedly querying for missing features def cache_missing_features ( conn : GraphKBConnection ) -> None : Args conn ( GraphKBConnection )","title":"cache_missing_features()"},{"location":"developer_reference/graphkb/match/#match_category_variant","text":"Returns a list of variants matching the input variant def match_category_variant ( conn : GraphKBConnection , gene_name : str , category : str , root_exclude_term : str = '' , gene_source : str = '' , gene_is_source_id : bool = False , ignore_cache : bool = False , ) -> List [ Variant ]: Args conn ( GraphKBConnection ): the graphkb connection object gene_name ( str ): the name of the gene the variant is in reference to category ( str ): the variant category (ex. copy loss) root_exclude_term ( str ) gene_source ( str ): The source database the gene is defined by (ex. ensembl) gene_is_source_id ( bool ): Indicates the gene name(s) input should be treated as sourceIds not names ignore_cache ( bool ) Returns List[ Variant ]: List of variant records from GraphKB which match the input Raises FeatureNotFoundError : The gene could not be found in GraphKB","title":"match_category_variant()"},{"location":"developer_reference/graphkb/match/#match_copy_variant","text":"Returns a list of variants matching the input variant def match_copy_variant ( conn : GraphKBConnection , gene_name : str , category : str , drop_homozygous : bool = False , ** kwargs ) -> List [ Variant ]: Args conn ( GraphKBConnection ): the graphkb connection object gene_name ( str ): the name of the gene the variant is in reference to category ( str ): the variant category (ex. copy loss) drop_homozygous ( bool ): Drop homozygous matches from the result when true Returns List[ Variant ]: List of variant records from GraphKB which match the input Raises ValueError : The input copy category is not recognized","title":"match_copy_variant()"},{"location":"developer_reference/graphkb/match/#positions_overlap","text":"Check if 2 Position records from GraphKB indicate an overlap def positions_overlap ( pos_record : BasicPosition , range_start : BasicPosition , range_end : Optional [ BasicPosition ] = None ) -> bool : Args pos_record ( BasicPosition ): the record to compare range_start ( BasicPosition ): the position record indicating the start of an uncertainty range range_end (Optional[ BasicPosition ]): the position record indicating the end of an uncertainty range Returns bool : True if the positions overlap Raises NotImplementedError : if a cytoband type position is given Note null values indicate not-specified or any","title":"positions_overlap()"},{"location":"developer_reference/graphkb/match/#compare_positional_variants","text":"Compare 2 variant records from GraphKB to determine if they are equivalent def compare_positional_variants ( variant : Union [ PositionalVariant , ParsedVariant ], reference_variant : Union [ PositionalVariant , ParsedVariant ], ) -> bool : Args variant (Union[ PositionalVariant , ParsedVariant ]): the input variant reference_variant (Union[ PositionalVariant , ParsedVariant ]): the reference (matched) variant record Returns bool : True if the records are equivalent","title":"compare_positional_variants()"},{"location":"developer_reference/graphkb/match/#match_positional_variant","text":"Given the HGVS+ representation of some positional variant, parse it and match it to annotations in GraphKB def match_positional_variant ( conn : GraphKBConnection , variant_string : str , reference1 : Optional [ str ] = None , reference2 : Optional [ str ] = None , gene_is_source_id : bool = False , gene_source : str = '' , ignore_cache : bool = False , ) -> List [ Variant ]: Args conn ( GraphKBConnection ) variant_string ( str ): the HGVS+ annotation string reference1 ( Optional[str] ): Explicitly specify the first reference link record (gene1) reference2 ( Optional[str] ): Explicitly specify the second reference link record (gene2) gene_is_source_id ( bool ): Indicates the gene name(s) input should be treated as sourceIds not names gene_source ( str ): The source database the gene is defined by (ex. ensembl) ignore_cache ( bool ) Returns List[ Variant ]: A list of matched statement records Raises NotImplementedError : thrown for uncertain position input (ranges) FeatureNotFoundError : One of the genes does not exist in GraphKB ValueError : the gene names were given both in the variant_string and explicitly Examples match_positional_variant ( conn , '(EWSR1,FLI1):fusion(e.1,e.2)' ) match_positional_variant ( conn , 'fusion(e.1,e.2)' , 'EWSR1' , 'FLI1' ) match_positional_variant ( conn , 'fusion(e.1,e.2)' , '#3:4' , '#4:5' ) match_positional_variant ( conn , 'fusion(e.1,e.2)' , '123' , '456' , gene_is_source_id = True , gene_source = 'entrez gene' ) match_positional_variant ( conn , 'KRAS:p.G12D' ) match_positional_variant ( conn , 'p.G12D' , 'KRAS' )","title":"match_positional_variant()"},{"location":"developer_reference/graphkb/statement/","text":"graphkb.statement categorize_relevance() Given the record ID of some relevance term, return the higher level categorization def categorize_relevance ( graphkb_conn : GraphKBConnection , relevance_rid : str , category_base_terms : CategoryBaseTermMapping = RELEVANCE_BASE_TERMS , ) -> str : Args graphkb_conn ( GraphKBConnection ) relevance_rid ( str ) category_base_terms ( CategoryBaseTermMapping ) Returns str","title":"graphkb.statement"},{"location":"developer_reference/graphkb/statement/#graphkbstatement","text":"","title":"graphkb.statement"},{"location":"developer_reference/graphkb/statement/#categorize_relevance","text":"Given the record ID of some relevance term, return the higher level categorization def categorize_relevance ( graphkb_conn : GraphKBConnection , relevance_rid : str , category_base_terms : CategoryBaseTermMapping = RELEVANCE_BASE_TERMS , ) -> str : Args graphkb_conn ( GraphKBConnection ) relevance_rid ( str ) category_base_terms ( CategoryBaseTermMapping ) Returns str","title":"categorize_relevance()"},{"location":"developer_reference/graphkb/types/","text":"graphkb.types Type annotations used for static type checking in this module Record Record : TypedDict = TypedDict ( 'Record' , { '@rid' : str , '@class' : str }) Attributes @rid ( str ) @class ( str ) EmbeddedRecord EmbeddedRecord : TypedDict = TypedDict ( 'EmbeddedRecord' , { '@class' : str }) Attributes @class ( str ) RecordLink RecordLink = Union [ str , Record ] OntologyLink OntologyLink = Union [ str , Ontology ] Position Position = Union [ BasicPosition , CytobandPosition ] CategoryBaseTermMapping CategoryBaseTermMapping = List [ Tuple [ str , List [ str ]]] class Ontology inherits Record Attributes sourceId ( str ) name ( str ) source ( RecordLink ) displayName ( str ) class BasicPosition inherits EmbeddedRecord Attributes pos ( int ) class CytobandPosition inherits EmbeddedRecord Attributes arm ( str ) majorBand ( str ) minorBand ( str ) class Variant inherits Record Attributes reference1 ( OntologyLink ) reference2 (Optional[ OntologyLink ]) type ( OntologyLink ) zygosity ( str ) germline ( bool ) displayName ( str ) class PositionalVariant inherits Variant Attributes break1Start (Union[ Position , CytobandPosition ]) break1End (Optional[Union[ Position , CytobandPosition ]]) break2Start (Optional[Union[ Position , CytobandPosition ]]) break2End (Optional[Union[ Position , CytobandPosition ]]) refSeq ( Optional[str] ) untemplatedSeq ( Optional[str] ) untemplatedSeqSize ( Optional[int] ) class ParsedVariant inherits TypedDict Attributes reference1 ( str ) reference2 ( Optional[str] ) type ( str ) zygosity ( str ) germline ( bool ) break1Start (Union[ Position , CytobandPosition ]) break1End (Optional[Union[ Position , CytobandPosition ]]) break2Start (Optional[Union[ Position , CytobandPosition ]]) break2End (Optional[Union[ Position , CytobandPosition ]]) refSeq ( Optional[str] ) untemplatedSeq ( Optional[str] ) untemplatedSeqSize ( Optional[int] ) class Statement inherits Record Attributes relevance ( OntologyLink ) subject ( OntologyLink ) conditions (List[ OntologyLink ]) evidence (List[ OntologyLink ]) evidenceLevel (List[ OntologyLink ]) source ( RecordLink ) sourceId ( str )","title":"graphkb.types"},{"location":"developer_reference/graphkb/types/#graphkbtypes","text":"Type annotations used for static type checking in this module","title":"graphkb.types"},{"location":"developer_reference/graphkb/types/#record","text":"Record : TypedDict = TypedDict ( 'Record' , { '@rid' : str , '@class' : str }) Attributes @rid ( str ) @class ( str )","title":"Record"},{"location":"developer_reference/graphkb/types/#embeddedrecord","text":"EmbeddedRecord : TypedDict = TypedDict ( 'EmbeddedRecord' , { '@class' : str }) Attributes @class ( str )","title":"EmbeddedRecord"},{"location":"developer_reference/graphkb/types/#recordlink","text":"RecordLink = Union [ str , Record ]","title":"RecordLink"},{"location":"developer_reference/graphkb/types/#ontologylink","text":"OntologyLink = Union [ str , Ontology ]","title":"OntologyLink"},{"location":"developer_reference/graphkb/types/#position","text":"Position = Union [ BasicPosition , CytobandPosition ]","title":"Position"},{"location":"developer_reference/graphkb/types/#categorybasetermmapping","text":"CategoryBaseTermMapping = List [ Tuple [ str , List [ str ]]]","title":"CategoryBaseTermMapping"},{"location":"developer_reference/graphkb/types/#class-ontology","text":"inherits Record Attributes sourceId ( str ) name ( str ) source ( RecordLink ) displayName ( str )","title":"class Ontology"},{"location":"developer_reference/graphkb/types/#class-basicposition","text":"inherits EmbeddedRecord Attributes pos ( int )","title":"class BasicPosition"},{"location":"developer_reference/graphkb/types/#class-cytobandposition","text":"inherits EmbeddedRecord Attributes arm ( str ) majorBand ( str ) minorBand ( str )","title":"class CytobandPosition"},{"location":"developer_reference/graphkb/types/#class-variant","text":"inherits Record Attributes reference1 ( OntologyLink ) reference2 (Optional[ OntologyLink ]) type ( OntologyLink ) zygosity ( str ) germline ( bool ) displayName ( str )","title":"class Variant"},{"location":"developer_reference/graphkb/types/#class-positionalvariant","text":"inherits Variant Attributes break1Start (Union[ Position , CytobandPosition ]) break1End (Optional[Union[ Position , CytobandPosition ]]) break2Start (Optional[Union[ Position , CytobandPosition ]]) break2End (Optional[Union[ Position , CytobandPosition ]]) refSeq ( Optional[str] ) untemplatedSeq ( Optional[str] ) untemplatedSeqSize ( Optional[int] )","title":"class PositionalVariant"},{"location":"developer_reference/graphkb/types/#class-parsedvariant","text":"inherits TypedDict Attributes reference1 ( str ) reference2 ( Optional[str] ) type ( str ) zygosity ( str ) germline ( bool ) break1Start (Union[ Position , CytobandPosition ]) break1End (Optional[Union[ Position , CytobandPosition ]]) break2Start (Optional[Union[ Position , CytobandPosition ]]) break2End (Optional[Union[ Position , CytobandPosition ]]) refSeq ( Optional[str] ) untemplatedSeq ( Optional[str] ) untemplatedSeqSize ( Optional[int] )","title":"class ParsedVariant"},{"location":"developer_reference/graphkb/types/#class-statement","text":"inherits Record Attributes relevance ( OntologyLink ) subject ( OntologyLink ) conditions (List[ OntologyLink ]) evidence (List[ OntologyLink ]) evidenceLevel (List[ OntologyLink ]) source ( RecordLink ) sourceId ( str )","title":"class Statement"},{"location":"developer_reference/graphkb/util/","text":"graphkb.util VERBOSE_ERROR_CODE VERBOSE_ERROR_CODE = ( logging . INFO + logging . DEBUG ) // 2 logger logger = logging . getLogger ( 'graphkb' ) LOG_LEVELS LOG_LEVELS = { 'info' : logging . INFO , 'debug' : logging . DEBUG , 'warn' : logging . WARN , 'error' : logging . ERROR , 'verbose' : VERBOSE_ERROR_CODE , class IterableNamespace inherits argparse.Namespace convert_to_rid_list() Given a list of records, return their record IDs def convert_to_rid_list ( records : Iterable [ Record ]) -> List [ str ]: Args records (Iterable[ Record ]) Returns List[str] looks_like_rid() Check if an input string looks like a GraphKB ID def looks_like_rid ( rid : str ) -> bool : Args rid ( str ) Returns bool convert_aa_3to1() Convert an Input string from 3 letter AA notation to 1 letter AA notation def convert_aa_3to1 ( three_letter_notation : str ) -> str : Args three_letter_notation ( str ) Returns str","title":"graphkb.util"},{"location":"developer_reference/graphkb/util/#graphkbutil","text":"","title":"graphkb.util"},{"location":"developer_reference/graphkb/util/#verbose_error_code","text":"VERBOSE_ERROR_CODE = ( logging . INFO + logging . DEBUG ) // 2","title":"VERBOSE_ERROR_CODE"},{"location":"developer_reference/graphkb/util/#logger","text":"logger = logging . getLogger ( 'graphkb' )","title":"logger"},{"location":"developer_reference/graphkb/util/#log_levels","text":"LOG_LEVELS = { 'info' : logging . INFO , 'debug' : logging . DEBUG , 'warn' : logging . WARN , 'error' : logging . ERROR , 'verbose' : VERBOSE_ERROR_CODE ,","title":"LOG_LEVELS"},{"location":"developer_reference/graphkb/util/#class-iterablenamespace","text":"inherits argparse.Namespace","title":"class IterableNamespace"},{"location":"developer_reference/graphkb/util/#convert_to_rid_list","text":"Given a list of records, return their record IDs def convert_to_rid_list ( records : Iterable [ Record ]) -> List [ str ]: Args records (Iterable[ Record ]) Returns List[str]","title":"convert_to_rid_list()"},{"location":"developer_reference/graphkb/util/#looks_like_rid","text":"Check if an input string looks like a GraphKB ID def looks_like_rid ( rid : str ) -> bool : Args rid ( str ) Returns bool","title":"looks_like_rid()"},{"location":"developer_reference/graphkb/util/#convert_aa_3to1","text":"Convert an Input string from 3 letter AA notation to 1 letter AA notation def convert_aa_3to1 ( three_letter_notation : str ) -> str : Args three_letter_notation ( str ) Returns str","title":"convert_aa_3to1()"},{"location":"developer_reference/graphkb/vocab/","text":"graphkb.vocab get_equivalent_terms() Get a list of terms equivalent to the current term up to the root term def get_equivalent_terms ( conn : GraphKBConnection , base_term_name : str , root_exclude_term : str = '' , ontology_class : str = 'Vocabulary' , ignore_cache : bool = False , ) -> List [ Ontology ]: Args conn ( GraphKBConnection ) base_term_name ( str ): the name to get superclasses of root_exclude_term ( str ): the parent term to exlcude along with all of its parent terms ontology_class ( str ) ignore_cache ( bool ) Returns List[ Ontology ] get_term_tree() Get terms equivalent to the base term by traversing the subclassOf tree and expanding related alias and cross reference edges def get_term_tree ( conn : GraphKBConnection , base_term_name : str , root_exclude_term : str = '' , ontology_class : str = 'Vocabulary' , include_superclasses : bool = True , ignore_cache : bool = False , ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object base_term_name ( str ): the term to use as the base of the subclass tree root_exclude_term ( str ) ontology_class ( str ): the default class to query. Defaults to 'Vocabulary' include_superclasses ( bool ): when True the query will include superclasses of the current term ignore_cache ( bool ) Returns List[ Ontology ]: GraphKB records Note: this must be done in 2 calls to avoid going up and down the tree in a single query (exclude adjacent siblings) get_term_by_name() Retrieve a vocaulary term by name def get_term_by_name ( conn : GraphKBConnection , name : str , ontology_class : str = 'Vocabulary' , ignore_cache : bool = False , ** kwargs , ) -> Ontology : Args conn ( GraphKBConnection ): the graphkb connection object name ( str ): the name of the Vocabulary term to retrieve ontology_class ( str ) ignore_cache ( bool ) Returns Ontology : Vocabulary record Raises AssertionError : more than one term or no terms with that name were found AssertionError : if the term was not found or more than 1 match was found (expected to be unique) get_terms_set() Get a set of terms of vocabulary given some base/parent term names. Returns the record IDs for the resulting terms def get_terms_set ( graphkb_conn : GraphKBConnection , base_terms : Iterable [ str ], ignore_cache : bool = False ) -> Set [ str ]: Args graphkb_conn ( GraphKBConnection ) base_terms ( Iterable[str] ) ignore_cache ( bool ) Returns Set[str]","title":"graphkb.vocab"},{"location":"developer_reference/graphkb/vocab/#graphkbvocab","text":"","title":"graphkb.vocab"},{"location":"developer_reference/graphkb/vocab/#get_equivalent_terms","text":"Get a list of terms equivalent to the current term up to the root term def get_equivalent_terms ( conn : GraphKBConnection , base_term_name : str , root_exclude_term : str = '' , ontology_class : str = 'Vocabulary' , ignore_cache : bool = False , ) -> List [ Ontology ]: Args conn ( GraphKBConnection ) base_term_name ( str ): the name to get superclasses of root_exclude_term ( str ): the parent term to exlcude along with all of its parent terms ontology_class ( str ) ignore_cache ( bool ) Returns List[ Ontology ]","title":"get_equivalent_terms()"},{"location":"developer_reference/graphkb/vocab/#get_term_tree","text":"Get terms equivalent to the base term by traversing the subclassOf tree and expanding related alias and cross reference edges def get_term_tree ( conn : GraphKBConnection , base_term_name : str , root_exclude_term : str = '' , ontology_class : str = 'Vocabulary' , include_superclasses : bool = True , ignore_cache : bool = False , ) -> List [ Ontology ]: Args conn ( GraphKBConnection ): the graphkb connection object base_term_name ( str ): the term to use as the base of the subclass tree root_exclude_term ( str ) ontology_class ( str ): the default class to query. Defaults to 'Vocabulary' include_superclasses ( bool ): when True the query will include superclasses of the current term ignore_cache ( bool ) Returns List[ Ontology ]: GraphKB records Note: this must be done in 2 calls to avoid going up and down the tree in a single query (exclude adjacent siblings)","title":"get_term_tree()"},{"location":"developer_reference/graphkb/vocab/#get_term_by_name","text":"Retrieve a vocaulary term by name def get_term_by_name ( conn : GraphKBConnection , name : str , ontology_class : str = 'Vocabulary' , ignore_cache : bool = False , ** kwargs , ) -> Ontology : Args conn ( GraphKBConnection ): the graphkb connection object name ( str ): the name of the Vocabulary term to retrieve ontology_class ( str ) ignore_cache ( bool ) Returns Ontology : Vocabulary record Raises AssertionError : more than one term or no terms with that name were found AssertionError : if the term was not found or more than 1 match was found (expected to be unique)","title":"get_term_by_name()"},{"location":"developer_reference/graphkb/vocab/#get_terms_set","text":"Get a set of terms of vocabulary given some base/parent term names. Returns the record IDs for the resulting terms def get_terms_set ( graphkb_conn : GraphKBConnection , base_terms : Iterable [ str ], ignore_cache : bool = False ) -> Set [ str ]: Args graphkb_conn ( GraphKBConnection ) base_terms ( Iterable[str] ) ignore_cache ( bool ) Returns Set[str]","title":"get_terms_set()"},{"location":"developer_reference/ipr/annotate/","text":"ipr.annotate handles annotating variants with annotation information from graphkb get_gene_information() Create the Gene Info object for upload to IPR with the other report information def get_gene_information ( graphkb_conn : GraphKBConnection , gene_names : Iterable [ str ] ) -> List [ IprGene ]: Args graphkb_conn ( GraphKBConnection ): [description] gene_names ( Iterable[str] ): [description] Returns List[ IprGene ] get_statements_from_variants() Given a list of variant records from GraphKB, return all the related statements def get_statements_from_variants ( graphkb_conn : GraphKBConnection , variants : List [ Record ] ) -> List [ Statement ]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants ( List[Record] ): list of variant records Returns List[Statement] : list of Statement records from graphkb get_second_pass_variants() Given a list of statements that have been matched. Convert these to new category variants to be used in a second-pass matching def get_second_pass_variants ( graphkb_conn : GraphKBConnection , statements : List [ Statement ] ) -> List [ Variant ]: Args graphkb_conn ( GraphKBConnection ) statements ( List[Statement] ) Returns List[Variant] get_ipr_statements_from_variants() Matches to GraphKB statements from the list of input variants. From these results matches again with the inferred variants. Then returns the results formatted for upload to IPR def get_ipr_statements_from_variants ( graphkb_conn : GraphKBConnection , matches : List [ Record ], disease_name : str ) -> List [ KbMatch ]: Args graphkb_conn ( GraphKBConnection ) matches ( List[Record] ) disease_name ( str ) Returns List[ KbMatch ] annotate_category_variants() Annotate variant calls with information from GraphKB and return these annotations in the IPR alterations format def annotate_category_variants ( graphkb_conn : GraphKBConnection , variants : List [ IprGeneVariant ], disease_name : str , copy_variant : bool = True , show_progress : bool = False , ) -> List [ KbMatch ]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants (List[ IprGeneVariant ]): list of variants disease_name ( str ) copy_variant ( bool ) show_progress ( bool ) Returns List[ KbMatch ]: list of kbMatches records for IPR annotate_positional_variants() Annotate variant calls with information from GraphKB and return these annotations in the IPR alterations format def annotate_positional_variants ( graphkb_conn : GraphKBConnection , variants : List [ IprVariant ], disease_name : str , show_progress : bool = False , ) -> List [ KbMatch ]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants (List[ IprVariant ]): list of variants. Defaults to []. disease_name ( str ) show_progress ( bool ) Returns List[ KbMatch ]: list of kbMatches records for IPR","title":"ipr.annotate"},{"location":"developer_reference/ipr/annotate/#iprannotate","text":"handles annotating variants with annotation information from graphkb","title":"ipr.annotate"},{"location":"developer_reference/ipr/annotate/#get_gene_information","text":"Create the Gene Info object for upload to IPR with the other report information def get_gene_information ( graphkb_conn : GraphKBConnection , gene_names : Iterable [ str ] ) -> List [ IprGene ]: Args graphkb_conn ( GraphKBConnection ): [description] gene_names ( Iterable[str] ): [description] Returns List[ IprGene ]","title":"get_gene_information()"},{"location":"developer_reference/ipr/annotate/#get_statements_from_variants","text":"Given a list of variant records from GraphKB, return all the related statements def get_statements_from_variants ( graphkb_conn : GraphKBConnection , variants : List [ Record ] ) -> List [ Statement ]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants ( List[Record] ): list of variant records Returns List[Statement] : list of Statement records from graphkb","title":"get_statements_from_variants()"},{"location":"developer_reference/ipr/annotate/#get_second_pass_variants","text":"Given a list of statements that have been matched. Convert these to new category variants to be used in a second-pass matching def get_second_pass_variants ( graphkb_conn : GraphKBConnection , statements : List [ Statement ] ) -> List [ Variant ]: Args graphkb_conn ( GraphKBConnection ) statements ( List[Statement] ) Returns List[Variant]","title":"get_second_pass_variants()"},{"location":"developer_reference/ipr/annotate/#get_ipr_statements_from_variants","text":"Matches to GraphKB statements from the list of input variants. From these results matches again with the inferred variants. Then returns the results formatted for upload to IPR def get_ipr_statements_from_variants ( graphkb_conn : GraphKBConnection , matches : List [ Record ], disease_name : str ) -> List [ KbMatch ]: Args graphkb_conn ( GraphKBConnection ) matches ( List[Record] ) disease_name ( str ) Returns List[ KbMatch ]","title":"get_ipr_statements_from_variants()"},{"location":"developer_reference/ipr/annotate/#annotate_category_variants","text":"Annotate variant calls with information from GraphKB and return these annotations in the IPR alterations format def annotate_category_variants ( graphkb_conn : GraphKBConnection , variants : List [ IprGeneVariant ], disease_name : str , copy_variant : bool = True , show_progress : bool = False , ) -> List [ KbMatch ]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants (List[ IprGeneVariant ]): list of variants disease_name ( str ) copy_variant ( bool ) show_progress ( bool ) Returns List[ KbMatch ]: list of kbMatches records for IPR","title":"annotate_category_variants()"},{"location":"developer_reference/ipr/annotate/#annotate_positional_variants","text":"Annotate variant calls with information from GraphKB and return these annotations in the IPR alterations format def annotate_positional_variants ( graphkb_conn : GraphKBConnection , variants : List [ IprVariant ], disease_name : str , show_progress : bool = False , ) -> List [ KbMatch ]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants (List[ IprVariant ]): list of variants. Defaults to []. disease_name ( str ) show_progress ( bool ) Returns List[ KbMatch ]: list of kbMatches records for IPR","title":"annotate_positional_variants()"},{"location":"developer_reference/ipr/connection/","text":"ipr.connection IMAGE_MAX IMAGE_MAX = 20 # cannot upload more than 20 images at a time class IprConnection IprConnection.request() Request wrapper to handle adding common headers and logging def request ( self , endpoint : str , method : str = 'GET' , ** kwargs ) -> Dict : Args endpoint ( str ): api endpoint, excluding the base uri method ( str ): the http method. Defaults to 'GET'. Returns Dict : the json response as a python dict IprConnection.post() Convenience method for making post requests def post ( self , uri : str , data : Dict = {}, ** kwargs ) -> Dict : Args uri ( str ) data ( Dict ) Returns Dict IprConnection.set_analyst_comments() Update report comments to an existing report def set_analyst_comments ( self , report_id : str , data : Dict ) -> Dict : Args report_id ( str ) data ( Dict ) Returns Dict Todo Add to main upload. Pending: https://www.bcgsc.ca/jira/browse/DEVSU-1177 IprConnection.post_images() Post images to the report def post_images ( self , report_id : str , files : Dict [ str , str ], data : Dict [ str , str ] = {}) -> None : Args report_id ( str ) files ( Dict[str, str] ) data ( Dict[str, str] )","title":"ipr.connection"},{"location":"developer_reference/ipr/connection/#iprconnection","text":"","title":"ipr.connection"},{"location":"developer_reference/ipr/connection/#image_max","text":"IMAGE_MAX = 20 # cannot upload more than 20 images at a time","title":"IMAGE_MAX"},{"location":"developer_reference/ipr/connection/#class-iprconnection","text":"","title":"class IprConnection"},{"location":"developer_reference/ipr/connection/#iprconnectionrequest","text":"Request wrapper to handle adding common headers and logging def request ( self , endpoint : str , method : str = 'GET' , ** kwargs ) -> Dict : Args endpoint ( str ): api endpoint, excluding the base uri method ( str ): the http method. Defaults to 'GET'. Returns Dict : the json response as a python dict","title":"IprConnection.request()"},{"location":"developer_reference/ipr/connection/#iprconnectionpost","text":"Convenience method for making post requests def post ( self , uri : str , data : Dict = {}, ** kwargs ) -> Dict : Args uri ( str ) data ( Dict ) Returns Dict","title":"IprConnection.post()"},{"location":"developer_reference/ipr/connection/#iprconnectionset_analyst_comments","text":"Update report comments to an existing report def set_analyst_comments ( self , report_id : str , data : Dict ) -> Dict : Args report_id ( str ) data ( Dict ) Returns Dict Todo Add to main upload. Pending: https://www.bcgsc.ca/jira/browse/DEVSU-1177","title":"IprConnection.set_analyst_comments()"},{"location":"developer_reference/ipr/connection/#iprconnectionpost_images","text":"Post images to the report def post_images ( self , report_id : str , files : Dict [ str , str ], data : Dict [ str , str ] = {}) -> None : Args report_id ( str ) files ( Dict[str, str] ) data ( Dict[str, str] )","title":"IprConnection.post_images()"},{"location":"developer_reference/ipr/inputs/","text":"ipr.inputs Read/Validate the variant input files SPECIFICATION SPECIFICATION = os . path . join ( os . path . dirname ( __file__ ), 'content.spec.json' ) COPY_REQ COPY_REQ = [ 'gene' , 'kbCategory' ] COPY_KEY COPY_KEY = [ 'gene' ] COPY_OPTIONAL COPY_OPTIONAL = [ 'cnvState' , 'copyChange' , 'lohState' , # Loss of Heterzygosity state - informative detail to analyst 'chromosomeBand' , 'start' , 'end' , 'size' , 'log2Cna' , 'cna' , ] SMALL_MUT_REQ SMALL_MUT_REQ = [ 'gene' , 'proteinChange' ] SMALL_MUT_KEY SMALL_MUT_KEY = SMALL_MUT_REQ + [ 'altSeq' , 'chromosome' , 'endPosition' , 'refSeq' , 'startPosition' , 'transcript' , SMALL_MUT_OPTIONAL SMALL_MUT_OPTIONAL = [ 'altSeq' , 'chromosome' , 'endPosition' , 'hgvsCds' , 'hgvsGenomic' , 'hgvsProtein' , 'ncbiBuild' , 'normalAltCount' , 'normalDepth' , 'normalRefCount' , 'refSeq' , 'rnaAltCount' , 'rnaDepth' , 'rnaRefCount' , 'startPosition' , 'transcript' , 'tumourAltCount' , 'tumourDepth' , 'tumourRefCount' , 'zygosity' , ] EXP_REQ EXP_REQ = [ 'gene' , 'kbCategory' ] EXP_KEY EXP_KEY = [ 'gene' ] EXP_OPTIONAL EXP_OPTIONAL = [ 'biopsySiteFoldChange' , 'biopsySitePercentile' , 'biopsySiteQC' , 'biopsySiteZScore' , 'biopsySitekIQR' , 'diseaseFoldChange' , 'diseasekIQR' , 'diseasePercentile' , 'diseaseQC' , 'diseaseZScore' , 'expressionState' , 'histogramImage' , 'primarySiteFoldChange' , 'primarySitekIQR' , 'primarySitePercentile' , 'primarySiteQC' , 'primarySiteZScore' , 'rnaReads' , 'rpkm' , 'tpm' , ] SV_REQ SV_REQ = [ 'eventType' , 'breakpoint' , 'gene1' , # prev: nterm_hugo 'gene2' , # prev: cterm_hugo 'exon1' , # n-terminal 'exon2' , # c-terminal ] SV_KEY SV_KEY = SV_REQ [:] SV_OPTIONAL SV_OPTIONAL = [ 'ctermTranscript' , 'ntermTranscript' , 'ctermGene' , # combined hugo ensembl form 'ntermGene' , # combined hugo ensembl form 'detectedIn' , 'conventionalName' , 'svg' , 'svgTitle' , 'name' , 'frame' , 'omicSupport' , 'highQuality' , ] DefaultValidatingDraft7Validator DefaultValidatingDraft7Validator = extend_with_default ( jsonschema . Draft7Validator ) validate_variant_rows() check that the required columns are present check that a unique key can be formed for each row drop any non-defined columns def validate_variant_rows ( rows : Iterable [ Dict ], required : List [ str ], optional : List [ str ], row_to_key : Callable ) -> List [ IprVariant ]: Args rows ( Iterable[Dict] ): the input files rows required ( List[str] ) optional ( List[str] ): list of optional column names row_to_key ( Callable ): function to generate a key for a given row Returns List[ IprVariant ]: the rows from the tab file as dictionaries Raises ValueError : row keys are not unique ValueError : A required column is missing preprocess_copy_variants() Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_copy_variants ( rows : Iterable [ Dict ]) -> List [ IprVariant ]: Args rows ( Iterable[Dict] ) Returns List[ IprVariant ] preprocess_small_mutations() Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_small_mutations ( rows : Iterable [ Dict ]) -> List [ IprGeneVariant ]: Args rows ( Iterable[Dict] ) Returns List[ IprGeneVariant ] preprocess_expression_variants() Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_expression_variants ( rows : Iterable [ Dict ]) -> List [ IprGeneVariant ]: Args rows ( Iterable[Dict] ) Returns List[ IprGeneVariant ] create_graphkb_sv_notation() Generate GKB style structural variant notation from a structural variant input row def create_graphkb_sv_notation ( row : IprStructuralVariant ) -> str : Args row ( IprStructuralVariant ) Returns str preprocess_structural_variants() Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_structural_variants ( rows : Iterable [ Dict ]) -> List [ IprVariant ]: Args rows ( Iterable[Dict] ) Returns List[ IprVariant ] check_variant_links() Check matching information for any genes with variants. Warn about genes with only one experimental measure. def check_variant_links ( small_mutations : List [ IprGeneVariant ], expression_variants : List [ IprGeneVariant ], copy_variants : List [ IprGeneVariant ], structural_variants : List [ IprStructuralVariant ], ) -> Set [ str ]: Args small_mutations (List[ IprGeneVariant ]): list of small mutations expression_variants (List[ IprGeneVariant ]): list of expression variants copy_variants (List[ IprGeneVariant ]): list of copy variants structural_variants (List[ IprStructuralVariant ]): list of structural variants Returns Set[str] : set of gene names with variants (used for filtering before upload to IPR) check_comparators() Given the optional content dictionary, check that based on the analyses present the correct/sufficient comparators have also been specified def check_comparators ( content : Dict , expresssionVariants : Iterable [ Dict ] = []) -> None : Args content ( Dict ) expresssionVariants ( Iterable[Dict] ) validate_report_content() Validate a report content input JSON object against the schema specification Adds defaults as reccommended by: https://python-jsonschema.readthedocs.io/en/latest/faq/#why-doesn-t-my-schema-s-default-property-set-the-default-on-my-instance def validate_report_content ( content : Dict , schema_file : str = SPECIFICATION ) -> None : Args content ( Dict ) schema_file ( str )","title":"ipr.inputs"},{"location":"developer_reference/ipr/inputs/#iprinputs","text":"Read/Validate the variant input files","title":"ipr.inputs"},{"location":"developer_reference/ipr/inputs/#specification","text":"SPECIFICATION = os . path . join ( os . path . dirname ( __file__ ), 'content.spec.json' )","title":"SPECIFICATION"},{"location":"developer_reference/ipr/inputs/#copy_req","text":"COPY_REQ = [ 'gene' , 'kbCategory' ]","title":"COPY_REQ"},{"location":"developer_reference/ipr/inputs/#copy_key","text":"COPY_KEY = [ 'gene' ]","title":"COPY_KEY"},{"location":"developer_reference/ipr/inputs/#copy_optional","text":"COPY_OPTIONAL = [ 'cnvState' , 'copyChange' , 'lohState' , # Loss of Heterzygosity state - informative detail to analyst 'chromosomeBand' , 'start' , 'end' , 'size' , 'log2Cna' , 'cna' , ]","title":"COPY_OPTIONAL"},{"location":"developer_reference/ipr/inputs/#small_mut_req","text":"SMALL_MUT_REQ = [ 'gene' , 'proteinChange' ]","title":"SMALL_MUT_REQ"},{"location":"developer_reference/ipr/inputs/#small_mut_key","text":"SMALL_MUT_KEY = SMALL_MUT_REQ + [ 'altSeq' , 'chromosome' , 'endPosition' , 'refSeq' , 'startPosition' , 'transcript' ,","title":"SMALL_MUT_KEY"},{"location":"developer_reference/ipr/inputs/#small_mut_optional","text":"SMALL_MUT_OPTIONAL = [ 'altSeq' , 'chromosome' , 'endPosition' , 'hgvsCds' , 'hgvsGenomic' , 'hgvsProtein' , 'ncbiBuild' , 'normalAltCount' , 'normalDepth' , 'normalRefCount' , 'refSeq' , 'rnaAltCount' , 'rnaDepth' , 'rnaRefCount' , 'startPosition' , 'transcript' , 'tumourAltCount' , 'tumourDepth' , 'tumourRefCount' , 'zygosity' , ]","title":"SMALL_MUT_OPTIONAL"},{"location":"developer_reference/ipr/inputs/#exp_req","text":"EXP_REQ = [ 'gene' , 'kbCategory' ]","title":"EXP_REQ"},{"location":"developer_reference/ipr/inputs/#exp_key","text":"EXP_KEY = [ 'gene' ]","title":"EXP_KEY"},{"location":"developer_reference/ipr/inputs/#exp_optional","text":"EXP_OPTIONAL = [ 'biopsySiteFoldChange' , 'biopsySitePercentile' , 'biopsySiteQC' , 'biopsySiteZScore' , 'biopsySitekIQR' , 'diseaseFoldChange' , 'diseasekIQR' , 'diseasePercentile' , 'diseaseQC' , 'diseaseZScore' , 'expressionState' , 'histogramImage' , 'primarySiteFoldChange' , 'primarySitekIQR' , 'primarySitePercentile' , 'primarySiteQC' , 'primarySiteZScore' , 'rnaReads' , 'rpkm' , 'tpm' , ]","title":"EXP_OPTIONAL"},{"location":"developer_reference/ipr/inputs/#sv_req","text":"SV_REQ = [ 'eventType' , 'breakpoint' , 'gene1' , # prev: nterm_hugo 'gene2' , # prev: cterm_hugo 'exon1' , # n-terminal 'exon2' , # c-terminal ]","title":"SV_REQ"},{"location":"developer_reference/ipr/inputs/#sv_key","text":"SV_KEY = SV_REQ [:]","title":"SV_KEY"},{"location":"developer_reference/ipr/inputs/#sv_optional","text":"SV_OPTIONAL = [ 'ctermTranscript' , 'ntermTranscript' , 'ctermGene' , # combined hugo ensembl form 'ntermGene' , # combined hugo ensembl form 'detectedIn' , 'conventionalName' , 'svg' , 'svgTitle' , 'name' , 'frame' , 'omicSupport' , 'highQuality' , ]","title":"SV_OPTIONAL"},{"location":"developer_reference/ipr/inputs/#defaultvalidatingdraft7validator","text":"DefaultValidatingDraft7Validator = extend_with_default ( jsonschema . Draft7Validator )","title":"DefaultValidatingDraft7Validator"},{"location":"developer_reference/ipr/inputs/#validate_variant_rows","text":"check that the required columns are present check that a unique key can be formed for each row drop any non-defined columns def validate_variant_rows ( rows : Iterable [ Dict ], required : List [ str ], optional : List [ str ], row_to_key : Callable ) -> List [ IprVariant ]: Args rows ( Iterable[Dict] ): the input files rows required ( List[str] ) optional ( List[str] ): list of optional column names row_to_key ( Callable ): function to generate a key for a given row Returns List[ IprVariant ]: the rows from the tab file as dictionaries Raises ValueError : row keys are not unique ValueError : A required column is missing","title":"validate_variant_rows()"},{"location":"developer_reference/ipr/inputs/#preprocess_copy_variants","text":"Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_copy_variants ( rows : Iterable [ Dict ]) -> List [ IprVariant ]: Args rows ( Iterable[Dict] ) Returns List[ IprVariant ]","title":"preprocess_copy_variants()"},{"location":"developer_reference/ipr/inputs/#preprocess_small_mutations","text":"Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_small_mutations ( rows : Iterable [ Dict ]) -> List [ IprGeneVariant ]: Args rows ( Iterable[Dict] ) Returns List[ IprGeneVariant ]","title":"preprocess_small_mutations()"},{"location":"developer_reference/ipr/inputs/#preprocess_expression_variants","text":"Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_expression_variants ( rows : Iterable [ Dict ]) -> List [ IprGeneVariant ]: Args rows ( Iterable[Dict] ) Returns List[ IprGeneVariant ]","title":"preprocess_expression_variants()"},{"location":"developer_reference/ipr/inputs/#create_graphkb_sv_notation","text":"Generate GKB style structural variant notation from a structural variant input row def create_graphkb_sv_notation ( row : IprStructuralVariant ) -> str : Args row ( IprStructuralVariant ) Returns str","title":"create_graphkb_sv_notation()"},{"location":"developer_reference/ipr/inputs/#preprocess_structural_variants","text":"Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_structural_variants ( rows : Iterable [ Dict ]) -> List [ IprVariant ]: Args rows ( Iterable[Dict] ) Returns List[ IprVariant ]","title":"preprocess_structural_variants()"},{"location":"developer_reference/ipr/inputs/#check_variant_links","text":"Check matching information for any genes with variants. Warn about genes with only one experimental measure. def check_variant_links ( small_mutations : List [ IprGeneVariant ], expression_variants : List [ IprGeneVariant ], copy_variants : List [ IprGeneVariant ], structural_variants : List [ IprStructuralVariant ], ) -> Set [ str ]: Args small_mutations (List[ IprGeneVariant ]): list of small mutations expression_variants (List[ IprGeneVariant ]): list of expression variants copy_variants (List[ IprGeneVariant ]): list of copy variants structural_variants (List[ IprStructuralVariant ]): list of structural variants Returns Set[str] : set of gene names with variants (used for filtering before upload to IPR)","title":"check_variant_links()"},{"location":"developer_reference/ipr/inputs/#check_comparators","text":"Given the optional content dictionary, check that based on the analyses present the correct/sufficient comparators have also been specified def check_comparators ( content : Dict , expresssionVariants : Iterable [ Dict ] = []) -> None : Args content ( Dict ) expresssionVariants ( Iterable[Dict] )","title":"check_comparators()"},{"location":"developer_reference/ipr/inputs/#validate_report_content","text":"Validate a report content input JSON object against the schema specification Adds defaults as reccommended by: https://python-jsonschema.readthedocs.io/en/latest/faq/#why-doesn-t-my-schema-s-default-property-set-the-default-on-my-instance def validate_report_content ( content : Dict , schema_file : str = SPECIFICATION ) -> None : Args content ( Dict ) schema_file ( str )","title":"validate_report_content()"},{"location":"developer_reference/ipr/ipr/","text":"ipr.ipr Contains functions specific to formatting reports for IPR that are unlikely to be used by other reporting systems filter_structural_variants() Filter structural variants to remove non-high quality events unless they are matched/annotated or they involve a gene that is a known fusion partner def filter_structural_variants ( structural_variants : List [ IprStructuralVariant ], kb_matches : List [ KbMatch ], gene_annotations : List [ IprGene ], ) -> List [ IprStructuralVariant ]: Args structural_variants (List[ IprStructuralVariant ]) kb_matches (List[ KbMatch ]) gene_annotations (List[ IprGene ]) Returns List[ IprStructuralVariant ] convert_statements_to_alterations() Given a set of statements matched from graphkb, convert these into their IPR equivalent representations def convert_statements_to_alterations ( graphkb_conn : GraphKBConnection , statements : List [ Statement ], disease_name : str , variant_matches : Iterable [ str ], ) -> List [ KbMatch ]: Args graphkb_conn ( GraphKBConnection ): the graphkb connection object statements ( List[Statement] ): list of statement records from graphkb disease_name ( str ): name of the cancer type for the patient being reported on variant_matches ( Iterable[str] ): the list of RIDs the variant matched for these statements Returns List[ KbMatch ]: IPR graphkb row representations Notes: - only report disease matched prognostic markers https://www.bcgsc.ca/jira/browse/GERO-72 and GERO-196 Raises ValueError : could not find the disease type in GraphKB select_expression_plots() Given the list of expression variants, determine which expression historgram plots should be included in the IPR upload. This filters them based on the graphkb annotations to avoid loading more images than are required def select_expression_plots ( kb_matches : List [ KbMatch ], all_variants : List [ IprVariant ] ) -> List [ Dict [ str , ImageDefinition ]]: Args kb_matches (List[ KbMatch ]): the IPR graphkb annoations for all variants all_variants (List[ IprVariant ]) Returns List[Dict[ str , ImageDefinition ]]: list of expression images to be loaded by IPR create_key_alterations() Creates the list of genomic key alterations which summarizes all the variants matched by the KB This list of matches is also used to create the variant counts def create_key_alterations ( kb_matches : List [ KbMatch ], all_variants : List [ IprVariant ], ) -> Tuple [ List [ Dict ], Dict ]: Args kb_matches (List[ KbMatch ]) all_variants (List[ IprVariant ]) Returns Tuple[List[Dict], Dict]","title":"ipr.ipr"},{"location":"developer_reference/ipr/ipr/#ipripr","text":"Contains functions specific to formatting reports for IPR that are unlikely to be used by other reporting systems","title":"ipr.ipr"},{"location":"developer_reference/ipr/ipr/#filter_structural_variants","text":"Filter structural variants to remove non-high quality events unless they are matched/annotated or they involve a gene that is a known fusion partner def filter_structural_variants ( structural_variants : List [ IprStructuralVariant ], kb_matches : List [ KbMatch ], gene_annotations : List [ IprGene ], ) -> List [ IprStructuralVariant ]: Args structural_variants (List[ IprStructuralVariant ]) kb_matches (List[ KbMatch ]) gene_annotations (List[ IprGene ]) Returns List[ IprStructuralVariant ]","title":"filter_structural_variants()"},{"location":"developer_reference/ipr/ipr/#convert_statements_to_alterations","text":"Given a set of statements matched from graphkb, convert these into their IPR equivalent representations def convert_statements_to_alterations ( graphkb_conn : GraphKBConnection , statements : List [ Statement ], disease_name : str , variant_matches : Iterable [ str ], ) -> List [ KbMatch ]: Args graphkb_conn ( GraphKBConnection ): the graphkb connection object statements ( List[Statement] ): list of statement records from graphkb disease_name ( str ): name of the cancer type for the patient being reported on variant_matches ( Iterable[str] ): the list of RIDs the variant matched for these statements Returns List[ KbMatch ]: IPR graphkb row representations Notes: - only report disease matched prognostic markers https://www.bcgsc.ca/jira/browse/GERO-72 and GERO-196 Raises ValueError : could not find the disease type in GraphKB","title":"convert_statements_to_alterations()"},{"location":"developer_reference/ipr/ipr/#select_expression_plots","text":"Given the list of expression variants, determine which expression historgram plots should be included in the IPR upload. This filters them based on the graphkb annotations to avoid loading more images than are required def select_expression_plots ( kb_matches : List [ KbMatch ], all_variants : List [ IprVariant ] ) -> List [ Dict [ str , ImageDefinition ]]: Args kb_matches (List[ KbMatch ]): the IPR graphkb annoations for all variants all_variants (List[ IprVariant ]) Returns List[Dict[ str , ImageDefinition ]]: list of expression images to be loaded by IPR","title":"select_expression_plots()"},{"location":"developer_reference/ipr/ipr/#create_key_alterations","text":"Creates the list of genomic key alterations which summarizes all the variants matched by the KB This list of matches is also used to create the variant counts def create_key_alterations ( kb_matches : List [ KbMatch ], all_variants : List [ IprVariant ], ) -> Tuple [ List [ Dict ], Dict ]: Args kb_matches (List[ KbMatch ]) all_variants (List[ IprVariant ]) Returns Tuple[List[Dict], Dict]","title":"create_key_alterations()"},{"location":"developer_reference/ipr/main/","text":"ipr.main CACHE_GENE_MINIMUM CACHE_GENE_MINIMUM = 5000 clean_unsupported_content() Remove unsupported content. This content is either added to facilitate creation or to support upcoming and soon to be supported content that we would like to implement but is not yet supported by the upload def clean_unsupported_content ( upload_content : Dict ) -> Dict : Args upload_content ( Dict ) Returns Dict create_report() Run the matching and create the report JSON for upload to IPR def create_report ( username : str , password : str , content : Dict , ipr_url : str = DEFAULT_URL , log_level : str = 'info' , output_json_path : str = None , always_write_output_json : bool = False , ipr_upload : bool = True , interactive : bool = False , graphkb_url : str = '' , generate_therapeutics : bool = False , ) -> Optional [ Dict ]: Args username ( str ): the username for connecting to GraphKB and IPR password ( str ): the password for connecting to GraphKB and IPR content ( Dict ): report content ipr_url ( str ): base URL to use in connecting to IPR log_level ( str ): the logging level output_json_path ( str ): path to a JSON file to output the report upload body. always_write_output_json ( bool ): with successful IPR upload ipr_upload ( bool ): upload report to ipr interactive ( bool ): progressbars for interactive users graphkb_url ( str ) generate_therapeutics ( bool ): create therapeutic options for upload with the report Returns Optional[Dict] : ipr_conn.upload_report return dictionary","title":"ipr.main"},{"location":"developer_reference/ipr/main/#iprmain","text":"","title":"ipr.main"},{"location":"developer_reference/ipr/main/#cache_gene_minimum","text":"CACHE_GENE_MINIMUM = 5000","title":"CACHE_GENE_MINIMUM"},{"location":"developer_reference/ipr/main/#clean_unsupported_content","text":"Remove unsupported content. This content is either added to facilitate creation or to support upcoming and soon to be supported content that we would like to implement but is not yet supported by the upload def clean_unsupported_content ( upload_content : Dict ) -> Dict : Args upload_content ( Dict ) Returns Dict","title":"clean_unsupported_content()"},{"location":"developer_reference/ipr/main/#create_report","text":"Run the matching and create the report JSON for upload to IPR def create_report ( username : str , password : str , content : Dict , ipr_url : str = DEFAULT_URL , log_level : str = 'info' , output_json_path : str = None , always_write_output_json : bool = False , ipr_upload : bool = True , interactive : bool = False , graphkb_url : str = '' , generate_therapeutics : bool = False , ) -> Optional [ Dict ]: Args username ( str ): the username for connecting to GraphKB and IPR password ( str ): the password for connecting to GraphKB and IPR content ( Dict ): report content ipr_url ( str ): base URL to use in connecting to IPR log_level ( str ): the logging level output_json_path ( str ): path to a JSON file to output the report upload body. always_write_output_json ( bool ): with successful IPR upload ipr_upload ( bool ): upload report to ipr interactive ( bool ): progressbars for interactive users graphkb_url ( str ) generate_therapeutics ( bool ): create therapeutic options for upload with the report Returns Optional[Dict] : ipr_conn.upload_report return dictionary","title":"create_report()"},{"location":"developer_reference/ipr/summary/","text":"ipr.summary OTHER_DISEASES OTHER_DISEASES = 'other disease types' ENTREZ_GENE_URL ENTREZ_GENE_URL = 'https://www.ncbi.nlm.nih.gov/gene' GRAPHKB_GUI GRAPHKB_GUI = 'https://graphkb.bcgsc.ca' filter_by_record_class() Given a list of records, return the subset matching a class or list of classes def filter_by_record_class ( record_list : List [ Dict ], * record_classes , exclude : bool = False ) -> List [ Dict ]: Args record_list ( List[Dict] ) Returns List[Dict] create_graphkb_link() Create a link for a set of statements to the GraphKB client def create_graphkb_link ( record_ids : List [ str ], record_class : str = 'Statement' , ) -> str : Args record_ids ( List[str] ) record_class ( str ) Returns str substitute_sentence_template() Create the filled-in sentence template for a given template and list of substitutions which may be the result of the aggregation of 1 or more statements def substitute_sentence_template ( template : str , conditions : List [ Record ], subjects : List [ Record ], relevance : Record , evidence : List [ Record ], statement_rids : List [ str ] = [], disease_matches : Set [ str ] = set (), ) -> str : Args template ( str ) conditions ( List[Record] ) subjects ( List[Record] ) relevance ( Record ) evidence ( List[Record] ) statement_rids ( List[str] ) disease_matches ( Set[str] ) Returns str aggregate_statements() Group Statements that only differ in disease conditions and evidence def aggregate_statements ( graphkb_conn : GraphKBConnection , template : str , statements : List [ Statement ], disease_matches : Set [ str ], ) -> Dict [ str , str ]: Args graphkb_conn ( GraphKBConnection ) template ( str ) statements ( List[Statement] ) disease_matches ( Set[str] ) Returns Dict[str, str] create_section_html() Generate HTML for a gene section of the comments def create_section_html ( graphkb_conn : GraphKBConnection , gene_name : str , sentences_by_statement_id : Dict [ str , str ], statements : Dict [ str , Statement ], exp_variants : List [ IprVariant ], ) -> str : Args graphkb_conn ( GraphKBConnection ) gene_name ( str ) sentences_by_statement_id ( Dict[str, str] ) statements ( Dict[str, Statement] ) exp_variants (List[ IprVariant ]) Returns str section_statements_by_genes() Determine the statements associated with each gene name def section_statements_by_genes ( graphkb_conn : GraphKBConnection , statements : Sequence [ Statement ] ) -> Dict [ str , Set [ str ]]: Args graphkb_conn ( GraphKBConnection ) statements ( Sequence[Statement] ) Returns Dict[str, Set[str]] summarize() Given a list of GraphKB matches generate a text summary to add to the report def summarize ( graphkb_conn : GraphKBConnection , matches : Sequence [ KbMatch ], disease_name : str , variants : List [ IprVariant ], ) -> str : Args graphkb_conn ( GraphKBConnection ) matches (Sequence[ KbMatch ]) disease_name ( str ) variants (List[ IprVariant ]) Returns str","title":"ipr.summary"},{"location":"developer_reference/ipr/summary/#iprsummary","text":"","title":"ipr.summary"},{"location":"developer_reference/ipr/summary/#other_diseases","text":"OTHER_DISEASES = 'other disease types'","title":"OTHER_DISEASES"},{"location":"developer_reference/ipr/summary/#entrez_gene_url","text":"ENTREZ_GENE_URL = 'https://www.ncbi.nlm.nih.gov/gene'","title":"ENTREZ_GENE_URL"},{"location":"developer_reference/ipr/summary/#graphkb_gui","text":"GRAPHKB_GUI = 'https://graphkb.bcgsc.ca'","title":"GRAPHKB_GUI"},{"location":"developer_reference/ipr/summary/#filter_by_record_class","text":"Given a list of records, return the subset matching a class or list of classes def filter_by_record_class ( record_list : List [ Dict ], * record_classes , exclude : bool = False ) -> List [ Dict ]: Args record_list ( List[Dict] ) Returns List[Dict]","title":"filter_by_record_class()"},{"location":"developer_reference/ipr/summary/#create_graphkb_link","text":"Create a link for a set of statements to the GraphKB client def create_graphkb_link ( record_ids : List [ str ], record_class : str = 'Statement' , ) -> str : Args record_ids ( List[str] ) record_class ( str ) Returns str","title":"create_graphkb_link()"},{"location":"developer_reference/ipr/summary/#substitute_sentence_template","text":"Create the filled-in sentence template for a given template and list of substitutions which may be the result of the aggregation of 1 or more statements def substitute_sentence_template ( template : str , conditions : List [ Record ], subjects : List [ Record ], relevance : Record , evidence : List [ Record ], statement_rids : List [ str ] = [], disease_matches : Set [ str ] = set (), ) -> str : Args template ( str ) conditions ( List[Record] ) subjects ( List[Record] ) relevance ( Record ) evidence ( List[Record] ) statement_rids ( List[str] ) disease_matches ( Set[str] ) Returns str","title":"substitute_sentence_template()"},{"location":"developer_reference/ipr/summary/#aggregate_statements","text":"Group Statements that only differ in disease conditions and evidence def aggregate_statements ( graphkb_conn : GraphKBConnection , template : str , statements : List [ Statement ], disease_matches : Set [ str ], ) -> Dict [ str , str ]: Args graphkb_conn ( GraphKBConnection ) template ( str ) statements ( List[Statement] ) disease_matches ( Set[str] ) Returns Dict[str, str]","title":"aggregate_statements()"},{"location":"developer_reference/ipr/summary/#create_section_html","text":"Generate HTML for a gene section of the comments def create_section_html ( graphkb_conn : GraphKBConnection , gene_name : str , sentences_by_statement_id : Dict [ str , str ], statements : Dict [ str , Statement ], exp_variants : List [ IprVariant ], ) -> str : Args graphkb_conn ( GraphKBConnection ) gene_name ( str ) sentences_by_statement_id ( Dict[str, str] ) statements ( Dict[str, Statement] ) exp_variants (List[ IprVariant ]) Returns str","title":"create_section_html()"},{"location":"developer_reference/ipr/summary/#section_statements_by_genes","text":"Determine the statements associated with each gene name def section_statements_by_genes ( graphkb_conn : GraphKBConnection , statements : Sequence [ Statement ] ) -> Dict [ str , Set [ str ]]: Args graphkb_conn ( GraphKBConnection ) statements ( Sequence[Statement] ) Returns Dict[str, Set[str]]","title":"section_statements_by_genes()"},{"location":"developer_reference/ipr/summary/#summarize","text":"Given a list of GraphKB matches generate a text summary to add to the report def summarize ( graphkb_conn : GraphKBConnection , matches : Sequence [ KbMatch ], disease_name : str , variants : List [ IprVariant ], ) -> str : Args graphkb_conn ( GraphKBConnection ) matches (Sequence[ KbMatch ]) disease_name ( str ) variants (List[ IprVariant ]) Returns str","title":"summarize()"},{"location":"developer_reference/ipr/therapeutic_options/","text":"ipr.therapeutic_options upload variant and report information to IPR create_therapeutic_options() Generate therapeutic options summary from the list of kb-matches def create_therapeutic_options ( graphkb_conn : GraphKBConnection , kb_matches : List [ KbMatch ], variants : List [ IprVariant ] ) -> List [ Dict ]: Args graphkb_conn ( GraphKBConnection ) kb_matches (List[ KbMatch ]) variants (List[ IprVariant ]) Returns List[Dict]","title":"ipr.therapeutic_options"},{"location":"developer_reference/ipr/therapeutic_options/#iprtherapeutic_options","text":"upload variant and report information to IPR","title":"ipr.therapeutic_options"},{"location":"developer_reference/ipr/therapeutic_options/#create_therapeutic_options","text":"Generate therapeutic options summary from the list of kb-matches def create_therapeutic_options ( graphkb_conn : GraphKBConnection , kb_matches : List [ KbMatch ], variants : List [ IprVariant ] ) -> List [ Dict ]: Args graphkb_conn ( GraphKBConnection ) kb_matches (List[ KbMatch ]) variants (List[ IprVariant ]) Returns List[Dict]","title":"create_therapeutic_options()"},{"location":"developer_reference/ipr/types/","text":"ipr.types IprVariant IprVariant = Union [ IprGeneVariant , IprStructuralVariant ] class KbMatch inherits TypedDict Attributes variant ( str ) variantType ( str ) approvedTherapy ( bool ) category ( str ) context ( str ) kbContextId ( str ) disease ( str ) evidenceLevel ( str ) kbStatementId ( str ) kbVariant ( str ) kbVariantId ( str ) matchedCancer ( bool ) reference ( str ) relevance ( str ) kbRelevanceId ( str ) class IprGeneVariant inherits TypedDict Attributes gene ( str ) key ( str ) variantType ( str ) variant ( str ) class IprGene inherits TypedDict Attributes name ( str ) cancerRelated ( Optional[bool] ) knownFusionPartner ( Optional[bool] ) knownSmallMutation ( Optional[bool] ) tumourSuppressor ( Optional[bool] ) oncogene ( Optional[bool] ) therapeuticAssociated ( Optional[bool] ) class IprStructuralVariant inherits TypedDict Attributes key ( str ) variantType ( str ) variant ( str ) gene1 ( str ) gene2 ( str ) exon1 ( int ) exon2 ( int ) class ImageDefinition inherits TypedDict Attributes key ( str ) path ( str )","title":"ipr.types"},{"location":"developer_reference/ipr/types/#iprtypes","text":"","title":"ipr.types"},{"location":"developer_reference/ipr/types/#iprvariant","text":"IprVariant = Union [ IprGeneVariant , IprStructuralVariant ]","title":"IprVariant"},{"location":"developer_reference/ipr/types/#class-kbmatch","text":"inherits TypedDict Attributes variant ( str ) variantType ( str ) approvedTherapy ( bool ) category ( str ) context ( str ) kbContextId ( str ) disease ( str ) evidenceLevel ( str ) kbStatementId ( str ) kbVariant ( str ) kbVariantId ( str ) matchedCancer ( bool ) reference ( str ) relevance ( str ) kbRelevanceId ( str )","title":"class KbMatch"},{"location":"developer_reference/ipr/types/#class-iprgenevariant","text":"inherits TypedDict Attributes gene ( str ) key ( str ) variantType ( str ) variant ( str )","title":"class IprGeneVariant"},{"location":"developer_reference/ipr/types/#class-iprgene","text":"inherits TypedDict Attributes name ( str ) cancerRelated ( Optional[bool] ) knownFusionPartner ( Optional[bool] ) knownSmallMutation ( Optional[bool] ) tumourSuppressor ( Optional[bool] ) oncogene ( Optional[bool] ) therapeuticAssociated ( Optional[bool] )","title":"class IprGene"},{"location":"developer_reference/ipr/types/#class-iprstructuralvariant","text":"inherits TypedDict Attributes key ( str ) variantType ( str ) variant ( str ) gene1 ( str ) gene2 ( str ) exon1 ( int ) exon2 ( int )","title":"class IprStructuralVariant"},{"location":"developer_reference/ipr/types/#class-imagedefinition","text":"inherits TypedDict Attributes key ( str ) path ( str )","title":"class ImageDefinition"},{"location":"developer_reference/ipr/util/","text":"ipr.util VERBOSE_ERROR_CODE VERBOSE_ERROR_CODE = ( logging . INFO + logging . DEBUG ) // 2 logger logger = logging . getLogger ( 'ipr' ) LOG_LEVELS LOG_LEVELS = { 'info' : logging . INFO , 'debug' : logging . DEBUG , 'warn' : logging . WARN , 'error' : logging . ERROR , 'verbose' : VERBOSE_ERROR_CODE , create_variant_name() Given an IPR variant row, create the variant representation to be used as the name of the variant def create_variant_name ( variant : IprVariant ) -> str : Args variant ( IprVariant ) Returns str create_variant_name_tuple() Given an IPR variant row, create the variant representation to be used as the name of the variant def create_variant_name_tuple ( variant : IprVariant ) -> Tuple [ str , str ]: Args variant ( IprVariant ) Returns Tuple[str, str] find_variant() Find a variant in a list of variants by its key and type def find_variant ( all_variants : List [ IprVariant ], variant_type : str , variant_key : str ) -> IprVariant : Args all_variants (List[ IprVariant ]) variant_type ( str ) variant_key ( str ) Returns IprVariant generate_ontology_preference_key() Generate a tuple key for comparing preferred ontology terms. def generate_ontology_preference_key ( record : Dict , sources_sort : Dict [ str , int ] = {}) -> Tuple : Args record ( Dict ) sources_sort ( Dict[str, int] ) Returns Tuple get_preferred_drug_representation() Given a Drug record, follow its linked records to find the preferred representation by following alias, deprecating, and cross reference links def get_preferred_drug_representation ( graphkb_conn : GraphKBConnection , drug_record_id : str ) -> Dict : Args graphkb_conn ( GraphKBConnection ) drug_record_id ( str ) Returns Dict get_preferred_gene_name() Given some Feature record ID return the preferred gene name def get_preferred_gene_name ( graphkb_conn : GraphKBConnection , record_id : str ) -> str : Args graphkb_conn ( GraphKBConnection ) record_id ( str ) Returns str","title":"ipr.util"},{"location":"developer_reference/ipr/util/#iprutil","text":"","title":"ipr.util"},{"location":"developer_reference/ipr/util/#verbose_error_code","text":"VERBOSE_ERROR_CODE = ( logging . INFO + logging . DEBUG ) // 2","title":"VERBOSE_ERROR_CODE"},{"location":"developer_reference/ipr/util/#logger","text":"logger = logging . getLogger ( 'ipr' )","title":"logger"},{"location":"developer_reference/ipr/util/#log_levels","text":"LOG_LEVELS = { 'info' : logging . INFO , 'debug' : logging . DEBUG , 'warn' : logging . WARN , 'error' : logging . ERROR , 'verbose' : VERBOSE_ERROR_CODE ,","title":"LOG_LEVELS"},{"location":"developer_reference/ipr/util/#create_variant_name","text":"Given an IPR variant row, create the variant representation to be used as the name of the variant def create_variant_name ( variant : IprVariant ) -> str : Args variant ( IprVariant ) Returns str","title":"create_variant_name()"},{"location":"developer_reference/ipr/util/#create_variant_name_tuple","text":"Given an IPR variant row, create the variant representation to be used as the name of the variant def create_variant_name_tuple ( variant : IprVariant ) -> Tuple [ str , str ]: Args variant ( IprVariant ) Returns Tuple[str, str]","title":"create_variant_name_tuple()"},{"location":"developer_reference/ipr/util/#find_variant","text":"Find a variant in a list of variants by its key and type def find_variant ( all_variants : List [ IprVariant ], variant_type : str , variant_key : str ) -> IprVariant : Args all_variants (List[ IprVariant ]) variant_type ( str ) variant_key ( str ) Returns IprVariant","title":"find_variant()"},{"location":"developer_reference/ipr/util/#generate_ontology_preference_key","text":"Generate a tuple key for comparing preferred ontology terms. def generate_ontology_preference_key ( record : Dict , sources_sort : Dict [ str , int ] = {}) -> Tuple : Args record ( Dict ) sources_sort ( Dict[str, int] ) Returns Tuple","title":"generate_ontology_preference_key()"},{"location":"developer_reference/ipr/util/#get_preferred_drug_representation","text":"Given a Drug record, follow its linked records to find the preferred representation by following alias, deprecating, and cross reference links def get_preferred_drug_representation ( graphkb_conn : GraphKBConnection , drug_record_id : str ) -> Dict : Args graphkb_conn ( GraphKBConnection ) drug_record_id ( str ) Returns Dict","title":"get_preferred_drug_representation()"},{"location":"developer_reference/ipr/util/#get_preferred_gene_name","text":"Given some Feature record ID return the preferred gene name def get_preferred_gene_name ( graphkb_conn : GraphKBConnection , record_id : str ) -> str : Args graphkb_conn ( GraphKBConnection ) record_id ( str ) Returns str","title":"get_preferred_gene_name()"},{"location":"graphkb/","text":"About GraphKB is a graph-based implementation of a cancer knowledge base. GraphKB is unique among other knowledge base projects in its inclusion of ontology relations and subsquent real-time leveraging of their inherent graph structure. Getting Started Users The simplest way to try out GraphKB is via the demo we provide here . simply click on the /graphkb link and enter the provided credentials ( graphkb_admin / graphkb_admin ). This will allow you to test out the application before having to set up your own instance. If your institution would like to host an instance of GraphKB please see the instuctions for developers and system administrators in the next section. Developers / Sys-Admins GraphKB can be installed/setup by itself or in combination with the PORI reporting application, IPR. To see instructions for setup of the complete platform please see the main install page . Loading Data When you setup/install GraphKB you will create a new and empty database. Most users will then want to load some standard content into their newly created instance. We have created scripts and modules to simplify this process. See the data loading page for more information. Using the Python Adaptor The python adaptor to GraphKB is provided for users who would like to incorporate an instance of GraphKB into their own scripts and pipelines. Additionally it is used by the IPR python adaptor to connect to GraphKB.","title":"About"},{"location":"graphkb/#about","text":"GraphKB is a graph-based implementation of a cancer knowledge base. GraphKB is unique among other knowledge base projects in its inclusion of ontology relations and subsquent real-time leveraging of their inherent graph structure.","title":"About"},{"location":"graphkb/#getting-started","text":"","title":"Getting Started"},{"location":"graphkb/#users","text":"The simplest way to try out GraphKB is via the demo we provide here . simply click on the /graphkb link and enter the provided credentials ( graphkb_admin / graphkb_admin ). This will allow you to test out the application before having to set up your own instance. If your institution would like to host an instance of GraphKB please see the instuctions for developers and system administrators in the next section.","title":"Users"},{"location":"graphkb/#developers-sys-admins","text":"GraphKB can be installed/setup by itself or in combination with the PORI reporting application, IPR. To see instructions for setup of the complete platform please see the main install page .","title":"Developers / Sys-Admins"},{"location":"graphkb/#loading-data","text":"When you setup/install GraphKB you will create a new and empty database. Most users will then want to load some standard content into their newly created instance. We have created scripts and modules to simplify this process. See the data loading page for more information.","title":"Loading Data"},{"location":"graphkb/#using-the-python-adaptor","text":"The python adaptor to GraphKB is provided for users who would like to incorporate an instance of GraphKB into their own scripts and pipelines. Additionally it is used by the IPR python adaptor to connect to GraphKB.","title":"Using the Python Adaptor"},{"location":"graphkb/loading_data/","text":"Loading Data We have provided a number of modules to automate loading external resources into GraphKB. Users can pick and choose which resources they would like to load or use the snakemake pipeline to load them all. Loading All Resources Loading GraphKB content can be done as an initialization step using snakemake (see instructions here ). This will download and load all open-data content by default into your newly created GraphKB instance. Loading Licensed Content Both COSMIC and DrugBank have some licensing on their content which will require users to create their own accounts with the respective resource. However, including them in the default load is trivial. Once you have your credentials, simply include the email/password parameters for the resource you would like to load as config arguments. snakemake -j 1 \\ --config drugbank_email = \"YOUR EMAIL\" \\ drugbank_password = \"YOUR PASSWORD\" \\ cosmic_email = \"YOUR EMAIL\" \\ cosmic_password = \"YOUR PASSWORD\" Popular Resources Most popular resources which have pre-built loaders provided for GraphKB are listed below. However, for an exhaustive list of all possible loaders, please see the loader project itself. ChEMBL https://www.ebi.ac.uk/chembl Drug definitions and relationships can be loaded from ChEMBL via their REST API. Disease Ontology https://disease-ontology.org Disease definitions and relationships are loaded from Data files provided by the Disease Ontology. DrugBank https://go.drugbank.com Drug Definitions and relationships along with cross references to the FDA drugs list are loaded from the XML database dumps of DrugBank Ensembl https://uswest.ensembl.org/index.html Gene, Transcript, and Protein definitions as well as cross-mappings to RefSeq versions Entrez API https://www.ncbi.nlm.nih.gov/books/NBK25501 Module used in other loaders for fetching publications (PubMed, PMC); genes (Entrez gene); RS ISs (snp), etc. from the NCBI Entrez API utitlies FDA SRS https://fdasis.nlm.nih.gov/srs The FDA substance registration system contains drug definitions and names FDA Approval Announcements https://www.fda.gov/drugs/resources-information-approved-drugs/hematologyoncology-cancer-approvals-safety-notifications Parses Oncology Approval Announcements from the FDA site, stores as evidence items HGNC https://www.genenames.org Gene names and definitions as well as cross-mappings to several other gene resources such as ensembl and entrez NCIt https://ncithesaurus.nci.nih.gov/ncitbrowser NCI Thesaurus which contains therapies, anatomical entities, and disease definitions. GraphKB Ontology JSON https://github.com/bcgsc/pori_graphkb_loader/tree/master/src/ontology This loads a simple JSON format describing a set of ontology terms Uberon https://uberon.github.io The uberon ontology contains anatomical entity definitions Cancer Genome Interpreter https://www.cancergenomeinterpreter.org/home This is an external knowledge base which can be imported as statements into GraphKB CIViC https://civicdb.org This is an external knowledge base which can be imported as statements into GraphKB ClinicalTrials.gov https://clinicaltrials.gov/ct2/home Contains details for clinical trials around the world. Where possible the drugs and disease terms associated with the trial are matched and linked to the trial when the data is loaded. OncoKB https://www.oncokb.org This is a legacy loader. It is written to load the actionability JSON files provided by OncoKB. As this is not an open data resource, using this loader will require licensing specific to your user/instance. This is an external knowledge base which can be imported as statements into GraphKB. DGIdb https://www.dgidb.org Loads Gene-Drug Interactions into GraphKB. These are used in exploring novel mutation targets DoCM http://docm.info This is an external knowledge base which can be imported as statements into GraphKB.","title":"Loading Data"},{"location":"graphkb/loading_data/#loading-data","text":"We have provided a number of modules to automate loading external resources into GraphKB. Users can pick and choose which resources they would like to load or use the snakemake pipeline to load them all.","title":"Loading Data"},{"location":"graphkb/loading_data/#loading-all-resources","text":"Loading GraphKB content can be done as an initialization step using snakemake (see instructions here ). This will download and load all open-data content by default into your newly created GraphKB instance.","title":"Loading All Resources"},{"location":"graphkb/loading_data/#loading-licensed-content","text":"Both COSMIC and DrugBank have some licensing on their content which will require users to create their own accounts with the respective resource. However, including them in the default load is trivial. Once you have your credentials, simply include the email/password parameters for the resource you would like to load as config arguments. snakemake -j 1 \\ --config drugbank_email = \"YOUR EMAIL\" \\ drugbank_password = \"YOUR PASSWORD\" \\ cosmic_email = \"YOUR EMAIL\" \\ cosmic_password = \"YOUR PASSWORD\"","title":"Loading Licensed Content"},{"location":"graphkb/loading_data/#popular-resources","text":"Most popular resources which have pre-built loaders provided for GraphKB are listed below. However, for an exhaustive list of all possible loaders, please see the loader project itself.","title":"Popular Resources"},{"location":"graphkb/loading_data/#chembl","text":"https://www.ebi.ac.uk/chembl Drug definitions and relationships can be loaded from ChEMBL via their REST API.","title":"ChEMBL"},{"location":"graphkb/loading_data/#disease-ontology","text":"https://disease-ontology.org Disease definitions and relationships are loaded from Data files provided by the Disease Ontology.","title":"Disease Ontology"},{"location":"graphkb/loading_data/#drugbank","text":"https://go.drugbank.com Drug Definitions and relationships along with cross references to the FDA drugs list are loaded from the XML database dumps of DrugBank","title":"DrugBank"},{"location":"graphkb/loading_data/#ensembl","text":"https://uswest.ensembl.org/index.html Gene, Transcript, and Protein definitions as well as cross-mappings to RefSeq versions","title":"Ensembl"},{"location":"graphkb/loading_data/#entrez-api","text":"https://www.ncbi.nlm.nih.gov/books/NBK25501 Module used in other loaders for fetching publications (PubMed, PMC); genes (Entrez gene); RS ISs (snp), etc. from the NCBI Entrez API utitlies","title":"Entrez API"},{"location":"graphkb/loading_data/#fda-srs","text":"https://fdasis.nlm.nih.gov/srs The FDA substance registration system contains drug definitions and names","title":"FDA SRS"},{"location":"graphkb/loading_data/#fda-approval-announcements","text":"https://www.fda.gov/drugs/resources-information-approved-drugs/hematologyoncology-cancer-approvals-safety-notifications Parses Oncology Approval Announcements from the FDA site, stores as evidence items","title":"FDA Approval Announcements"},{"location":"graphkb/loading_data/#hgnc","text":"https://www.genenames.org Gene names and definitions as well as cross-mappings to several other gene resources such as ensembl and entrez","title":"HGNC"},{"location":"graphkb/loading_data/#ncit","text":"https://ncithesaurus.nci.nih.gov/ncitbrowser NCI Thesaurus which contains therapies, anatomical entities, and disease definitions.","title":"NCIt"},{"location":"graphkb/loading_data/#graphkb-ontology-json","text":"https://github.com/bcgsc/pori_graphkb_loader/tree/master/src/ontology This loads a simple JSON format describing a set of ontology terms","title":"GraphKB Ontology JSON"},{"location":"graphkb/loading_data/#uberon","text":"https://uberon.github.io The uberon ontology contains anatomical entity definitions","title":"Uberon"},{"location":"graphkb/loading_data/#cancer-genome-interpreter","text":"https://www.cancergenomeinterpreter.org/home This is an external knowledge base which can be imported as statements into GraphKB","title":"Cancer Genome Interpreter"},{"location":"graphkb/loading_data/#civic","text":"https://civicdb.org This is an external knowledge base which can be imported as statements into GraphKB","title":"CIViC"},{"location":"graphkb/loading_data/#clinicaltrialsgov","text":"https://clinicaltrials.gov/ct2/home Contains details for clinical trials around the world. Where possible the drugs and disease terms associated with the trial are matched and linked to the trial when the data is loaded.","title":"ClinicalTrials.gov"},{"location":"graphkb/loading_data/#oncokb","text":"https://www.oncokb.org This is a legacy loader. It is written to load the actionability JSON files provided by OncoKB. As this is not an open data resource, using this loader will require licensing specific to your user/instance. This is an external knowledge base which can be imported as statements into GraphKB.","title":"OncoKB"},{"location":"graphkb/loading_data/#dgidb","text":"https://www.dgidb.org Loads Gene-Drug Interactions into GraphKB. These are used in exploring novel mutation targets","title":"DGIdb"},{"location":"graphkb/loading_data/#docm","text":"http://docm.info This is an external knowledge base which can be imported as statements into GraphKB.","title":"DoCM"},{"location":"graphkb/matching/","text":"Ontology Algorithm The matching algorithm implemented by this adaptor heavily uses the Graph Structure of GraphKB to resolve aliases, generalisms, etc. The default behaviour of this algorithm is described below and shown in the related examples. This is primarily accomplished via the similarTo query type provided by the GraphKB API. Definitions The entire knowledge base is defined as the graph, \\(G = (V, E)\\) . For any given query let the subgraph of \\(G\\) containing only vertices of the class type specified in the query (ex. Disease) be, \\(V_t\\) . All edges between these vertices are then categorized into two disjoint sets: synonym-like ( \\(E_{syn}\\) ) or inheritance-like ( \\(E_{inh}\\) ). By default the synonym-like edges are: GeneralizationOf, AliasOf, CrossReferenceOf, DeprecatedBy, and Infers. Whereas the inheritance-like edges are: SubClassOf, and ElementOf. Edge Groups are Configurable These are the default division of Edges. However, classes used for the edge sets can be configured in the query body of similarTo type queries sent to GraphKB Synonym-like edges are treated as undirected and therefore the set of synonym-like edges used for the following steps can be written \\[ \\begin{equation} E_\\text{usyn} = \\bigcup_{uv \\in E_\\text{syn}} \\{uv,vu\\} \\end{equation} \\] Disease matching on the following graph will be used as a running example Match by Name Let the set of vertices (from \\(V_t\\) ) where the name attribute is an exact match to the input query name be \\(V_m\\) . Resolve Aliases Follow synonym-like edges from the set of name-matched vertices Let \\(P(v_0,v,E)\\) be the set of vertices that forms a path from vertex \\(v_0\\) to \\(v\\) along the edges in \\(E\\) and in their direction. If no such path exists, then \\(P = \\emptyset\\) . The set of vertices that resolve aliases in the query are formed by including all paths from \\(v_0 \\in V_\\text{m}\\) along the \\(E_\\text{usyn}\\) edges. \\[ \\begin{equation} V_\\text{syn} = V_\\text{m} \\cup \\bigcup_{v_0 \\in V_\\text{m}} \\bigcup_{ v_i \\in V_\\text{t} } P(v_0,v_i,E_\\text{usyn}) \\end{equation} \\] Follow the Inheritance-like Edges The inheritance-like edges are followed next. Unlike the synonym-like edges, directionality is important here. By following the inheritence-like edges in \\(E_\\text{inh}\\) from and to all vertices \\(V_\\text{syn}\\) we create the set of inheritence vertices. This is the set of vertics involved in paths which originate or terminate in a vertex perviously matched. \\[ \\begin{equation} V_\\text{inh} = V_\\text{syn} \\cup \\bigcup_{v_0 \\in V_\\text{syn}} \\bigcup_{ v_i \\in V_\\text{t} } P(v_0,v_i,E_\\text{inh}) \\cup P(v_i,v_0,E_\\text{inh}) \\end{equation} \\] Resolve Final Aliases Finally, we repeat the synonym-like expansion \\[ \\begin{equation} V_\\text{f} = V_\\text{inh} \\cup \\bigcup_{v_0 \\in V_\\text{inh}} \\bigcup_{ v_i \\in V_\\text{t} } P(v_0,v_i,E_\\text{usyn}) \\end{equation} \\] Bounding Note that the above Graph Traversals are bounded by input parameters to specify a maximum depth.","title":"Ontology Algorithm"},{"location":"graphkb/matching/#ontology-algorithm","text":"The matching algorithm implemented by this adaptor heavily uses the Graph Structure of GraphKB to resolve aliases, generalisms, etc. The default behaviour of this algorithm is described below and shown in the related examples. This is primarily accomplished via the similarTo query type provided by the GraphKB API.","title":"Ontology Algorithm"},{"location":"graphkb/matching/#definitions","text":"The entire knowledge base is defined as the graph, \\(G = (V, E)\\) . For any given query let the subgraph of \\(G\\) containing only vertices of the class type specified in the query (ex. Disease) be, \\(V_t\\) . All edges between these vertices are then categorized into two disjoint sets: synonym-like ( \\(E_{syn}\\) ) or inheritance-like ( \\(E_{inh}\\) ). By default the synonym-like edges are: GeneralizationOf, AliasOf, CrossReferenceOf, DeprecatedBy, and Infers. Whereas the inheritance-like edges are: SubClassOf, and ElementOf. Edge Groups are Configurable These are the default division of Edges. However, classes used for the edge sets can be configured in the query body of similarTo type queries sent to GraphKB Synonym-like edges are treated as undirected and therefore the set of synonym-like edges used for the following steps can be written \\[ \\begin{equation} E_\\text{usyn} = \\bigcup_{uv \\in E_\\text{syn}} \\{uv,vu\\} \\end{equation} \\] Disease matching on the following graph will be used as a running example","title":"Definitions"},{"location":"graphkb/matching/#match-by-name","text":"Let the set of vertices (from \\(V_t\\) ) where the name attribute is an exact match to the input query name be \\(V_m\\) .","title":"Match by Name"},{"location":"graphkb/matching/#resolve-aliases","text":"Follow synonym-like edges from the set of name-matched vertices Let \\(P(v_0,v,E)\\) be the set of vertices that forms a path from vertex \\(v_0\\) to \\(v\\) along the edges in \\(E\\) and in their direction. If no such path exists, then \\(P = \\emptyset\\) . The set of vertices that resolve aliases in the query are formed by including all paths from \\(v_0 \\in V_\\text{m}\\) along the \\(E_\\text{usyn}\\) edges. \\[ \\begin{equation} V_\\text{syn} = V_\\text{m} \\cup \\bigcup_{v_0 \\in V_\\text{m}} \\bigcup_{ v_i \\in V_\\text{t} } P(v_0,v_i,E_\\text{usyn}) \\end{equation} \\]","title":"Resolve Aliases"},{"location":"graphkb/matching/#follow-the-inheritance-like-edges","text":"The inheritance-like edges are followed next. Unlike the synonym-like edges, directionality is important here. By following the inheritence-like edges in \\(E_\\text{inh}\\) from and to all vertices \\(V_\\text{syn}\\) we create the set of inheritence vertices. This is the set of vertics involved in paths which originate or terminate in a vertex perviously matched. \\[ \\begin{equation} V_\\text{inh} = V_\\text{syn} \\cup \\bigcup_{v_0 \\in V_\\text{syn}} \\bigcup_{ v_i \\in V_\\text{t} } P(v_0,v_i,E_\\text{inh}) \\cup P(v_i,v_0,E_\\text{inh}) \\end{equation} \\]","title":"Follow the Inheritance-like Edges"},{"location":"graphkb/matching/#resolve-final-aliases","text":"Finally, we repeat the synonym-like expansion \\[ \\begin{equation} V_\\text{f} = V_\\text{inh} \\cup \\bigcup_{v_0 \\in V_\\text{inh}} \\bigcup_{ v_i \\in V_\\text{t} } P(v_0,v_i,E_\\text{usyn}) \\end{equation} \\]","title":"Resolve Final Aliases"},{"location":"graphkb/matching/#bounding","text":"Note that the above Graph Traversals are bounded by input parameters to specify a maximum depth.","title":"Bounding"},{"location":"graphkb/matching/gene/","text":"Gene Example The get_equivalent_features() method is used to find genes equivalent to the input/target feature. from graphkb.match import get_equivalent_features genes = get_equivalent_features ( graphkb_conn , 'KRAS' ) This will use a similar algorithm to what we have seen above in the disease matching example. In the graph above the relationship types shown are: GeneralizationOf (G), ElementOf (E), DeprecatedBy (D), and CrossReferenceOf (X). Match by Name As before, the first thing done is to match the input name Resolve Aliases The next step is to resolve equivalent names of the current set of terms. Follow the Elements Tree The next step is to follow the element relationships. This is treated the same as the subclassing except now our \"tree edge\" is the ElementOf relationship type. Resolve Final Aliases Finally we expand the current set of terms by alias terms again to capture aliases of the more general parent and more specific child terms expanded in the previous step. We have now collected all of the different terms for KRAS","title":"Gene Example"},{"location":"graphkb/matching/gene/#gene-example","text":"The get_equivalent_features() method is used to find genes equivalent to the input/target feature. from graphkb.match import get_equivalent_features genes = get_equivalent_features ( graphkb_conn , 'KRAS' ) This will use a similar algorithm to what we have seen above in the disease matching example. In the graph above the relationship types shown are: GeneralizationOf (G), ElementOf (E), DeprecatedBy (D), and CrossReferenceOf (X).","title":"Gene Example"},{"location":"graphkb/matching/gene/#match-by-name","text":"As before, the first thing done is to match the input name","title":"Match by Name"},{"location":"graphkb/matching/gene/#resolve-aliases","text":"The next step is to resolve equivalent names of the current set of terms.","title":"Resolve Aliases"},{"location":"graphkb/matching/gene/#follow-the-elements-tree","text":"The next step is to follow the element relationships. This is treated the same as the subclassing except now our \"tree edge\" is the ElementOf relationship type.","title":"Follow the Elements Tree"},{"location":"graphkb/matching/gene/#resolve-final-aliases","text":"Finally we expand the current set of terms by alias terms again to capture aliases of the more general parent and more specific child terms expanded in the previous step. We have now collected all of the different terms for KRAS","title":"Resolve Final Aliases"},{"location":"graphkb/scripting/","text":"User Manual The GraphKB python adapter is a python package to facilitate interacting with the GraphKB API. The GraphKB API is a REST API https://graphkb.bcgsc.ca/api) . The openapi specification is hosted here: https://graphkb-api.bcgsc.ca/api/spec . The client also contains documentation on the background and features of GraphKB This adapter adds functions for common queries as well as for paginating and authenticating Getting Started Install the python adapter with pip pip install graphkb This will require python 3.6 or greater. Next, start incorporating graphkb into your own python project/script. The script below gets version information from graphkb from graphkb import GraphKBConnection gkb_conn = GraphKBConnection () # authenticate the current user gkb_conn . login ( 'myusername' , 'mypassword' ) # get the version information version_metadata = gkb_conn . request ( '/version' ) Querying GraphKB uses the /query endpoint which takes the query arguments in the request body. See the openapi specification for more details on how to build this object. Matching Variants There are 2 main matching functions, one of positional variants and one for category variants. Let's take a look at a couple of examples from graphkb import GraphKBConnection from graphkb.match import match_positional_variant gkb_conn = GraphKBConnection () gkb_conn . login ( 'myusername' , 'mypassword' ) variant_matches = match_positional_variant ( gkb_conn , 'KRAS:p.G12D' ) This will give you a list of variants from GraphKB that are considered to match the input. We can then use this list of variants to fetch related annotations from graphkb.util import convert_to_rid_list annotations = gkb_conn . query ({ 'target' : 'Statement' , 'filters' : { 'conditions' : convert_to_rid_list ( variant_matches ), 'operator' : 'CONTAINSANY' } }) This will fetch a list of statements where any of the matched variants are conditions for the statement","title":"User Manual"},{"location":"graphkb/scripting/#user-manual","text":"The GraphKB python adapter is a python package to facilitate interacting with the GraphKB API. The GraphKB API is a REST API https://graphkb.bcgsc.ca/api) . The openapi specification is hosted here: https://graphkb-api.bcgsc.ca/api/spec . The client also contains documentation on the background and features of GraphKB This adapter adds functions for common queries as well as for paginating and authenticating","title":"User Manual"},{"location":"graphkb/scripting/#getting-started","text":"Install the python adapter with pip pip install graphkb This will require python 3.6 or greater. Next, start incorporating graphkb into your own python project/script. The script below gets version information from graphkb from graphkb import GraphKBConnection gkb_conn = GraphKBConnection () # authenticate the current user gkb_conn . login ( 'myusername' , 'mypassword' ) # get the version information version_metadata = gkb_conn . request ( '/version' ) Querying GraphKB uses the /query endpoint which takes the query arguments in the request body. See the openapi specification for more details on how to build this object.","title":"Getting Started"},{"location":"graphkb/scripting/#matching-variants","text":"There are 2 main matching functions, one of positional variants and one for category variants. Let's take a look at a couple of examples from graphkb import GraphKBConnection from graphkb.match import match_positional_variant gkb_conn = GraphKBConnection () gkb_conn . login ( 'myusername' , 'mypassword' ) variant_matches = match_positional_variant ( gkb_conn , 'KRAS:p.G12D' ) This will give you a list of variants from GraphKB that are considered to match the input. We can then use this list of variants to fetch related annotations from graphkb.util import convert_to_rid_list annotations = gkb_conn . query ({ 'target' : 'Statement' , 'filters' : { 'conditions' : convert_to_rid_list ( variant_matches ), 'operator' : 'CONTAINSANY' } }) This will fetch a list of statements where any of the matched variants are conditions for the statement","title":"Matching Variants"},{"location":"graphkb/scripting/intro_tutorial/","text":"Matching Tutorial This tutorial will cover how to get started using GraphKB to annotate your variants. There is an interative/jupyter version of this tutorial ( tutorial.ipynb ) which can be run in a web browser using google colab or a local jupyter server Install Install graphkb as a dependency of your python script (It is recommended to use a virtual environment) pip install graphkb Connecting to the API The first thing to do is setting up the connection to the API from graphkb import GraphKBConnection GKB_API_URL = 'https://pori-demo.bcgsc.ca/graphkb-api/api' GKB_USER = 'colab_demo' GKB_PASSWORD = 'colab_demo' graphkb_conn = GraphKBConnection ( GKB_API_URL , use_global_cache = False ) Next, use this to login graphkb_conn . login ( GKB_USER , GKB_PASSWORD ) This will store the credentials passed on the connection object and re-login as required. Variant Matches For this example we are going to try matching a protein change ( p.G12D ) on the gene ( KRAS ). from graphkb.match import match_positional_variant variant_name = 'KRAS:p.G12D' variant_matches = match_positional_variant ( graphkb_conn , variant_name ) for match in variant_matches : print ( variant_name , 'will match' , match [ 'displayName' ]) From this step you should see something like this (actual content will vary depending on the instance of the GraphKB API/DB you are using) KRAS:p.G12D will match KRAS:p.G12 KRAS:p.G12D will match KRAS:p.G12X KRAS:p.G12D will match KRAS:p.G12D KRAS:p.G12D will match KRAS:p.G12mut KRAS:p.G12D will match KRAS:p.(G12_G13)mut KRAS:p.G12D will match KRAS:p.?12mut KRAS:p.G12D will match KRAS:p.G12D KRAS:p.G12D will match chr12:g.25398284C>T KRAS:p.G12D will match KRAS:p.G12mut KRAS:p.G12D will match KRAS mutation As you can see above the match function has pulled similar/equivalent variant representations which we will then use to match statements. Next, use these variant matches to find the related statements Statement Annotations from graphkb.constants import BASE_RETURN_PROPERTIES , GENERIC_RETURN_PROPERTIES from graphkb.util import convert_to_rid_list # return properties should be customized to the users needs return_props = ( BASE_RETURN_PROPERTIES + [ 'sourceId' , 'source.name' , 'source.displayName' ] + [ f 'conditions. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'subject. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'evidence. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'relevance. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'evidenceLevel. { p } ' for p in GENERIC_RETURN_PROPERTIES ] ) statements = graphkb_conn . query ( { 'target' : 'Statement' , 'filters' : { 'conditions' : convert_to_rid_list ( variant_matches ), 'operator' : 'CONTAINSANY' }, 'returnProperties' : return_props , } ) for statement in statements [: 5 ]: print ( statement [ 'relevance' ][ 'displayName' ], statement [ 'subject' ][ 'displayName' ], statement [ 'source' ][ 'displayName' ] if statement [ 'source' ] else '' , ) This should output lines similar to the following resistance gefitinib [C1855] CIViC likely pathogenic lung cancer [DOID:1324] DoCM Categorizing Statements Something we often want to know is if a statement is therapeutic, or prognostic, etc. The naive approach is to base this on a list of known terms or a regex pattern. In GraphKB we can leverage the ontology structure instead. In this example we will look for all terms that would indicate a therapeutically relevent statement. To do this we pick our 'base' terms. These are the terms we consider to be the highest level of the ontology tree, the most general term for that category. from graphkb.vocab import get_term_tree BASE_THERAPEUTIC_TERMS = 'therapeutic efficacy' therapeutic_terms = get_term_tree ( graphkb_conn , BASE_THERAPEUTIC_TERMS , include_superclasses = False ) print ( f 'Found { len ( therapeutic_terms ) } equivalent terms' ) for term in therapeutic_terms : print ( '-' , term [ 'name' ]) print () This will result in output like Found 13 equivalent terms - therapeutic efficacy - targetable - response - sensitivity - likely sensitivity - no sensitivity - no response - resistance - reduced sensitivity - likely resistance - innate resistance - acquired resistance - no resistance We can filter the statements we have already retrieved, or we can add this to our original query and filter before we retrive from the API statements = graphkb_conn . query ( { 'target' : 'Statement' , 'filters' : { 'AND' : [ { 'conditions' : convert_to_rid_list ( variant_matches ), 'operator' : 'CONTAINSANY' }, { 'relevance' : convert_to_rid_list ( therapeutic_terms ), 'operator' : 'IN' }, ] }, 'returnProperties' : return_props , } ) for statement in statements : print ( statement [ 'relevance' ][ 'displayName' ]) Similar filtering can be done for the other properties and any other base-term classification you would like to use. Use the graph view at https://graphkb.bcgsc.ca to explore record relationships and decide on the categories you would like to use. The full code for this tutorial can be downloaded here","title":"Matching Tutorial"},{"location":"graphkb/scripting/intro_tutorial/#matching-tutorial","text":"This tutorial will cover how to get started using GraphKB to annotate your variants. There is an interative/jupyter version of this tutorial ( tutorial.ipynb ) which can be run in a web browser using google colab or a local jupyter server","title":"Matching Tutorial"},{"location":"graphkb/scripting/intro_tutorial/#install","text":"Install graphkb as a dependency of your python script (It is recommended to use a virtual environment) pip install graphkb","title":"Install"},{"location":"graphkb/scripting/intro_tutorial/#connecting-to-the-api","text":"The first thing to do is setting up the connection to the API from graphkb import GraphKBConnection GKB_API_URL = 'https://pori-demo.bcgsc.ca/graphkb-api/api' GKB_USER = 'colab_demo' GKB_PASSWORD = 'colab_demo' graphkb_conn = GraphKBConnection ( GKB_API_URL , use_global_cache = False ) Next, use this to login graphkb_conn . login ( GKB_USER , GKB_PASSWORD ) This will store the credentials passed on the connection object and re-login as required.","title":"Connecting to the API"},{"location":"graphkb/scripting/intro_tutorial/#variant-matches","text":"For this example we are going to try matching a protein change ( p.G12D ) on the gene ( KRAS ). from graphkb.match import match_positional_variant variant_name = 'KRAS:p.G12D' variant_matches = match_positional_variant ( graphkb_conn , variant_name ) for match in variant_matches : print ( variant_name , 'will match' , match [ 'displayName' ]) From this step you should see something like this (actual content will vary depending on the instance of the GraphKB API/DB you are using) KRAS:p.G12D will match KRAS:p.G12 KRAS:p.G12D will match KRAS:p.G12X KRAS:p.G12D will match KRAS:p.G12D KRAS:p.G12D will match KRAS:p.G12mut KRAS:p.G12D will match KRAS:p.(G12_G13)mut KRAS:p.G12D will match KRAS:p.?12mut KRAS:p.G12D will match KRAS:p.G12D KRAS:p.G12D will match chr12:g.25398284C>T KRAS:p.G12D will match KRAS:p.G12mut KRAS:p.G12D will match KRAS mutation As you can see above the match function has pulled similar/equivalent variant representations which we will then use to match statements. Next, use these variant matches to find the related statements","title":"Variant Matches"},{"location":"graphkb/scripting/intro_tutorial/#statement-annotations","text":"from graphkb.constants import BASE_RETURN_PROPERTIES , GENERIC_RETURN_PROPERTIES from graphkb.util import convert_to_rid_list # return properties should be customized to the users needs return_props = ( BASE_RETURN_PROPERTIES + [ 'sourceId' , 'source.name' , 'source.displayName' ] + [ f 'conditions. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'subject. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'evidence. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'relevance. { p } ' for p in GENERIC_RETURN_PROPERTIES ] + [ f 'evidenceLevel. { p } ' for p in GENERIC_RETURN_PROPERTIES ] ) statements = graphkb_conn . query ( { 'target' : 'Statement' , 'filters' : { 'conditions' : convert_to_rid_list ( variant_matches ), 'operator' : 'CONTAINSANY' }, 'returnProperties' : return_props , } ) for statement in statements [: 5 ]: print ( statement [ 'relevance' ][ 'displayName' ], statement [ 'subject' ][ 'displayName' ], statement [ 'source' ][ 'displayName' ] if statement [ 'source' ] else '' , ) This should output lines similar to the following resistance gefitinib [C1855] CIViC likely pathogenic lung cancer [DOID:1324] DoCM","title":"Statement Annotations"},{"location":"graphkb/scripting/intro_tutorial/#categorizing-statements","text":"Something we often want to know is if a statement is therapeutic, or prognostic, etc. The naive approach is to base this on a list of known terms or a regex pattern. In GraphKB we can leverage the ontology structure instead. In this example we will look for all terms that would indicate a therapeutically relevent statement. To do this we pick our 'base' terms. These are the terms we consider to be the highest level of the ontology tree, the most general term for that category. from graphkb.vocab import get_term_tree BASE_THERAPEUTIC_TERMS = 'therapeutic efficacy' therapeutic_terms = get_term_tree ( graphkb_conn , BASE_THERAPEUTIC_TERMS , include_superclasses = False ) print ( f 'Found { len ( therapeutic_terms ) } equivalent terms' ) for term in therapeutic_terms : print ( '-' , term [ 'name' ]) print () This will result in output like Found 13 equivalent terms - therapeutic efficacy - targetable - response - sensitivity - likely sensitivity - no sensitivity - no response - resistance - reduced sensitivity - likely resistance - innate resistance - acquired resistance - no resistance We can filter the statements we have already retrieved, or we can add this to our original query and filter before we retrive from the API statements = graphkb_conn . query ( { 'target' : 'Statement' , 'filters' : { 'AND' : [ { 'conditions' : convert_to_rid_list ( variant_matches ), 'operator' : 'CONTAINSANY' }, { 'relevance' : convert_to_rid_list ( therapeutic_terms ), 'operator' : 'IN' }, ] }, 'returnProperties' : return_props , } ) for statement in statements : print ( statement [ 'relevance' ][ 'displayName' ]) Similar filtering can be done for the other properties and any other base-term classification you would like to use. Use the graph view at https://graphkb.bcgsc.ca to explore record relationships and decide on the categories you would like to use. The full code for this tutorial can be downloaded here","title":"Categorizing Statements"},{"location":"graphkb/scripting/snpsift/","text":"Annotate SNPSift Files The script annotate_snpsift.py can be used to match variants from input files to an instance of GraphKB. Copy the script locally and install the package dependencies. Must use Python3.6 or higher pip3 install graphkb pandas Then the annotator can be run as follows python annotate_snpsift.py <INPUT FILES> --output graphkb_annotations.tsv By default this will use the pori-demo version of GraphKB which has a limited amount of data. This demo version is intended for demonstration/testing only and a custom or shared production instance of the GraphKB API. This can be configured via the GraphKB arguments. See the help menu for a full list of arguments. python annotate_snpsift.py -h The output file will contain the variant name and the annotations pulled from GraphKB.","title":"Annotate SNPSift Files"},{"location":"graphkb/scripting/snpsift/#annotate-snpsift-files","text":"The script annotate_snpsift.py can be used to match variants from input files to an instance of GraphKB. Copy the script locally and install the package dependencies. Must use Python3.6 or higher pip3 install graphkb pandas Then the annotator can be run as follows python annotate_snpsift.py <INPUT FILES> --output graphkb_annotations.tsv By default this will use the pori-demo version of GraphKB which has a limited amount of data. This demo version is intended for demonstration/testing only and a custom or shared production instance of the GraphKB API. This can be configured via the GraphKB arguments. See the help menu for a full list of arguments. python annotate_snpsift.py -h The output file will contain the variant name and the annotations pulled from GraphKB.","title":"Annotate SNPSift Files"},{"location":"graphkb/scripting/variant_strings/","text":"Annotate Variant List The script annotate_variant_list.py can be used to match variants from input '= files to an instance of GraphKB. Copy the script locally and install the package dependencies. This example script expects a file with a single field (variant) and no header. Each line should be a separate HGVS-like variant notation. For example KRAS:p.G12D KRAS:p.G13E Must use Python3.6 or higher pip3 install graphkb pandas Then the annotator can be run as follows python annotate_variant_list.py <INPUT FILE> --output graphkb_annotations.tsv By default this will use the pori-demo version of GraphKB which has a limited amount of data. This demo version is intended for demonstration/testing only and a custom or shared production instance of the GraphKB API. This can be configured via the GraphKB arguments. See the help menu for a full list of arguments. python annotate_variant_list.py -h The output file will contain the variant name and the annotations pulled from GraphKB. The names of the variants matched will be included in the output file as \"variant_matches\", this will be a semi-colon delimited list of all the variants which were considered to be present/equivalent based on the input variant. For example if the input where KRAS:p.G12D we might expect to see something like this KRAS mutation;KRAS:p.(G12_G13)mut;KRAS:p.?12mut;KRAS:p.G12;KRAS:p.G12D;KRAS:p.G12mut;chr12:g.25398284C>T We can see the variant has matched less specific forms of the same variant such as KRAS mutation or KRAS:p.(G12_G13)mut (any KRAS mutation at G12 or G13)","title":"Annotate Variant List"},{"location":"graphkb/scripting/variant_strings/#annotate-variant-list","text":"The script annotate_variant_list.py can be used to match variants from input '= files to an instance of GraphKB. Copy the script locally and install the package dependencies. This example script expects a file with a single field (variant) and no header. Each line should be a separate HGVS-like variant notation. For example KRAS:p.G12D KRAS:p.G13E Must use Python3.6 or higher pip3 install graphkb pandas Then the annotator can be run as follows python annotate_variant_list.py <INPUT FILE> --output graphkb_annotations.tsv By default this will use the pori-demo version of GraphKB which has a limited amount of data. This demo version is intended for demonstration/testing only and a custom or shared production instance of the GraphKB API. This can be configured via the GraphKB arguments. See the help menu for a full list of arguments. python annotate_variant_list.py -h The output file will contain the variant name and the annotations pulled from GraphKB. The names of the variants matched will be included in the output file as \"variant_matches\", this will be a semi-colon delimited list of all the variants which were considered to be present/equivalent based on the input variant. For example if the input where KRAS:p.G12D we might expect to see something like this KRAS mutation;KRAS:p.(G12_G13)mut;KRAS:p.?12mut;KRAS:p.G12;KRAS:p.G12D;KRAS:p.G12mut;chr12:g.25398284C>T We can see the variant has matched less specific forms of the same variant such as KRAS mutation or KRAS:p.(G12_G13)mut (any KRAS mutation at G12 or G13)","title":"Annotate Variant List"},{"location":"ipr/","text":"About Integrated Pipeline Reports (IPR) is the main reporting application of IPR. It is a web application that is used to review and curate reports which summarize the interpretation of molecular data from precision oncology patients. This project is modularized across 3 repositories: web client , REST API , and a python adaptor . The API and web client are servers and are provided as docker containers. The python adaptor is used to build reports and upload them into IPR. Reports in IPR are divided into a series of sections. These are either create by the IPR python adaptor (ex. knowledgebase matches section), manually curated post-report creation (ex. analyst comments); or generated beforehand and included in the content passed to IPR via the python adaptor (ex. optional analyses).","title":"About"},{"location":"ipr/#about","text":"Integrated Pipeline Reports (IPR) is the main reporting application of IPR. It is a web application that is used to review and curate reports which summarize the interpretation of molecular data from precision oncology patients. This project is modularized across 3 repositories: web client , REST API , and a python adaptor . The API and web client are servers and are provided as docker containers. The python adaptor is used to build reports and upload them into IPR. Reports in IPR are divided into a series of sections. These are either create by the IPR python adaptor (ex. knowledgebase matches section), manually curated post-report creation (ex. analyst comments); or generated beforehand and included in the content passed to IPR via the python adaptor (ex. optional analyses).","title":"About"},{"location":"ipr/upload/","text":"Uploading A Report Before you can generate and upload reports you will first need to install the package with pip pip install ipr This will require python 3.6 or greater. this can now be used as a command line tool ipr -h or as part of a script (see the developer reference ) from argparse import Namespace from ipr.main import create_report create_report ( ... ) The pre-generated content (ex. variant calls) of the report is passed to this function via a JSON object. The various sections of this object are desribed in the core variants and optional analyses sections. The full specification for the upload can be viewed/explored via the JSON schema explorer here Most content is optional with a few top-level elements required { \"project\" : \"string\" , \"patientId\" : \"PATIENT 0\" , \"template\" : \"genomic\" , \"kbDiseaseMatch\" : \"colorectal cancer\" } All top-level fields are listed in detail below Field Type Example Description kbDiseaseMatch (required) string \"colorectal cancer\" the disease name to used in matching to GraphKB. This will be used to populate the matchedCancer flag patientId (required) string project (required) string \"POG\" The name of the project that this report will be uploaded to template (required) string \"genomic\" the type of report the user is uploading. This must match the name of one of the template types in the database. These are configurable via the IPR client interface but the default values in the demo database are genomic and probe ageOfConsent number alternateIdentifier string biopsyDate string \"2021-06-04T16:36:37.279Z\" the date the biopsy/sample was taken/collected biopsyName string \"biop1\" ploidy string \"diploid\" The ploidy model used for calling copy variants and determining mutation affected alleles presentationDate string date this case is scheduled to be presented to the molecular tumour board subtyping string \"Luminal A\" tumourContent number 45 the tumour content or purity of the current sample","title":"Uploading A Report"},{"location":"ipr/upload/#uploading-a-report","text":"Before you can generate and upload reports you will first need to install the package with pip pip install ipr This will require python 3.6 or greater. this can now be used as a command line tool ipr -h or as part of a script (see the developer reference ) from argparse import Namespace from ipr.main import create_report create_report ( ... ) The pre-generated content (ex. variant calls) of the report is passed to this function via a JSON object. The various sections of this object are desribed in the core variants and optional analyses sections. The full specification for the upload can be viewed/explored via the JSON schema explorer here Most content is optional with a few top-level elements required { \"project\" : \"string\" , \"patientId\" : \"PATIENT 0\" , \"template\" : \"genomic\" , \"kbDiseaseMatch\" : \"colorectal cancer\" } All top-level fields are listed in detail below Field Type Example Description kbDiseaseMatch (required) string \"colorectal cancer\" the disease name to used in matching to GraphKB. This will be used to populate the matchedCancer flag patientId (required) string project (required) string \"POG\" The name of the project that this report will be uploaded to template (required) string \"genomic\" the type of report the user is uploading. This must match the name of one of the template types in the database. These are configurable via the IPR client interface but the default values in the demo database are genomic and probe ageOfConsent number alternateIdentifier string biopsyDate string \"2021-06-04T16:36:37.279Z\" the date the biopsy/sample was taken/collected biopsyName string \"biop1\" ploidy string \"diploid\" The ploidy model used for calling copy variants and determining mutation affected alleles presentationDate string date this case is scheduled to be presented to the molecular tumour board subtyping string \"Luminal A\" tumourContent number 45 the tumour content or purity of the current sample","title":"Uploading A Report"},{"location":"ipr/core_variants/","text":"About The core variant types are: expression variants, copy number variants, structural variants, and small mutations. All of these variants are matched against GraphKB and annotated by the python IPR adaptor during upload to IPR.","title":"About"},{"location":"ipr/core_variants/#about","text":"The core variant types are: expression variants, copy number variants, structural variants, and small mutations. All of these variants are matched against GraphKB and annotated by the python IPR adaptor during upload to IPR.","title":"About"},{"location":"ipr/core_variants/copy/","text":"Copy Variants Copy variants should be passed to the IPR python adaptor in the main report content JSON. { \"copyVariants\" : [ // varia nts ] } Each variant is an object which may contain any of the following fields Field Type Example Description gene (required) string \"KRAS\" the gene name kbCategory (required) string? the graphkb copy variant vocabulary term this variant belongs to. By default only amplifications and deep deletions are matched chromosomeBand string \"X:p12.2\" cna number 1.22 The copy number alteration (CNA) ratio copyChange integer -2 the ploidy corrected copy change value end integer? the genomic end position of the copy segment this gene copy number was called from log2Cna number lohState string \"HET\" the loss-of-heterozygosity category for this gene region start integer? the genomic start position of the copy segment this gene copy number was called from","title":"Copy Variants"},{"location":"ipr/core_variants/copy/#copy-variants","text":"Copy variants should be passed to the IPR python adaptor in the main report content JSON. { \"copyVariants\" : [ // varia nts ] } Each variant is an object which may contain any of the following fields Field Type Example Description gene (required) string \"KRAS\" the gene name kbCategory (required) string? the graphkb copy variant vocabulary term this variant belongs to. By default only amplifications and deep deletions are matched chromosomeBand string \"X:p12.2\" cna number 1.22 The copy number alteration (CNA) ratio copyChange integer -2 the ploidy corrected copy change value end integer? the genomic end position of the copy segment this gene copy number was called from log2Cna number lohState string \"HET\" the loss-of-heterozygosity category for this gene region start integer? the genomic start position of the copy segment this gene copy number was called from","title":"Copy Variants"},{"location":"ipr/core_variants/expression/","text":"Expression Variants In an effort to be extensible and quick to use there are only 2 required fields for expression variants: the name of the gene (gene) and whether the expression of that gene is up-regulated or down-regulated (kbCategory). Field Type Example Description gene string KRAS the gene name (or source identifier) kbCategory string increased expression the graphkb expression variant vocabulary term this variant belongs to. One of: increased expression, reduced expression The kbCategory field is how IPR knows this row/entry should be treated as a variant/outlier or just expression information input for context. This way the thresholds and cut-off values used are determined by the users uploading the reports. Computing the various expression metrics is largely optional and done prior by the user prior to upload/report-creation. These metrics are displayed to the analyst reviewing the case along with the variant status. The standard fields we provide input for are listed below. As with the other variants, these should be passed to the IPR python adaptor in the main report content JSON. { \"expressionVariants\" : [ // varia nts ] } Each variant is an object which may contain any of the following fields (in addition to the required fields) Field Type Description biopsySiteFoldChange number? the fold change with respect to the median of the biopsy site expression comparator cohort biopsySitePercentile number? the percentile with respect to the biopsy site expression comparator cohort biopsySiteQC number? biopsySiteZScore number? the zscore with respect to the biopsy site expression comparator cohort biopsySitekIQR number? the kIQR with respect to the biopsy site expression comparator cohort diseaseFoldChange number? the fold change with respect to the median of the disease expression comparator cohort diseasePercentile number? the percentile with respect to the disease expression comparator cohort diseaseQC number? diseaseZScore number? the zscore with respect to the disease expression comparator cohort diseasekIQR number? the kIQR with respect to the disease expression comparator cohort expressionState string Overloads the kb-category just for display purposes (does not affect matching) histogramImage string? path to the expression density/histogram plot primarySiteFoldChange number? the fold change with respect to the median of the primary site expression comparator cohort primarySitePercentile number? the percentile with respect to the primary site expression comparator cohort primarySiteQC number? primarySiteZScore number? the zscore with respect to the primary site expression comparator cohort primarySitekIQR number? the kIQR with respect to the primary site expression comparator cohort rnaReads number? rpkm number? reads per kilobase of transcript, per million mapped reads tpm number? transcript per million Metrics Z-Score The z-score (A.K.A. standard score ) is a metric used to describe a data point relative to a distribution with respect to the variance within that distribution. Formally it is defined as \\[ z = \\frac{\\mu - x}{\\sigma} \\] k-IQR The k interquartile range is a used to compare a point against a distribution. It is defined as the distance of a given point from the median scaled by the interquartile range \\[ k = \\frac{Q_2 - x}{Q_3 - Q_1} \\] This metric is similar to the z-score but more robust to outliers. Percentile The percentile rank is a non-parametric way of measuring a given data point relative to the distribution. Comparators All of the standard expression metrics in IPR are expected to be calculated against a reference distribution of expression samples. To this end, IPR provides a number of fields to record which distributions were used. This ensures that the final result is interperable and reproducible. A complete list of comparators can be found in the comparators section of the user manual. Expression comparators fall into three main groups: disease, primary site, and biopsy site. Disease The reference distribution that most closely matches the diagnosis of the current sample Primary Site The reference distribution that most closely matches the non-diseased/normal expression of the primary site tissue Biopsy Site The reference distribution that most closely matches the non-diseased/normal expression of the biopsy site tissue. This is important for metastatic samples where the biopsy site and primary site differ. Images The use can optionally include expression density plots to allow the user to view the relative expression of the current sample compared to a specific distribution. Info These will be passed to the report upload function via the images section of the JSON input key: expDensity\\.(\\S+) In the above the pattern is expected to be expDensity.<gene name> where the gene name matches the gene name(s) used for the expression variant definitions. Where these plots are included for the genes listed as variants they will be shown along with the expression data in the expression variants section. In the interface these will appear in the actions tab where available. This will bring up the expression density plot in a popup","title":"Expression Variants"},{"location":"ipr/core_variants/expression/#expression-variants","text":"In an effort to be extensible and quick to use there are only 2 required fields for expression variants: the name of the gene (gene) and whether the expression of that gene is up-regulated or down-regulated (kbCategory). Field Type Example Description gene string KRAS the gene name (or source identifier) kbCategory string increased expression the graphkb expression variant vocabulary term this variant belongs to. One of: increased expression, reduced expression The kbCategory field is how IPR knows this row/entry should be treated as a variant/outlier or just expression information input for context. This way the thresholds and cut-off values used are determined by the users uploading the reports. Computing the various expression metrics is largely optional and done prior by the user prior to upload/report-creation. These metrics are displayed to the analyst reviewing the case along with the variant status. The standard fields we provide input for are listed below. As with the other variants, these should be passed to the IPR python adaptor in the main report content JSON. { \"expressionVariants\" : [ // varia nts ] } Each variant is an object which may contain any of the following fields (in addition to the required fields) Field Type Description biopsySiteFoldChange number? the fold change with respect to the median of the biopsy site expression comparator cohort biopsySitePercentile number? the percentile with respect to the biopsy site expression comparator cohort biopsySiteQC number? biopsySiteZScore number? the zscore with respect to the biopsy site expression comparator cohort biopsySitekIQR number? the kIQR with respect to the biopsy site expression comparator cohort diseaseFoldChange number? the fold change with respect to the median of the disease expression comparator cohort diseasePercentile number? the percentile with respect to the disease expression comparator cohort diseaseQC number? diseaseZScore number? the zscore with respect to the disease expression comparator cohort diseasekIQR number? the kIQR with respect to the disease expression comparator cohort expressionState string Overloads the kb-category just for display purposes (does not affect matching) histogramImage string? path to the expression density/histogram plot primarySiteFoldChange number? the fold change with respect to the median of the primary site expression comparator cohort primarySitePercentile number? the percentile with respect to the primary site expression comparator cohort primarySiteQC number? primarySiteZScore number? the zscore with respect to the primary site expression comparator cohort primarySitekIQR number? the kIQR with respect to the primary site expression comparator cohort rnaReads number? rpkm number? reads per kilobase of transcript, per million mapped reads tpm number? transcript per million","title":"Expression Variants"},{"location":"ipr/core_variants/expression/#metrics","text":"","title":"Metrics"},{"location":"ipr/core_variants/expression/#z-score","text":"The z-score (A.K.A. standard score ) is a metric used to describe a data point relative to a distribution with respect to the variance within that distribution. Formally it is defined as \\[ z = \\frac{\\mu - x}{\\sigma} \\]","title":"Z-Score"},{"location":"ipr/core_variants/expression/#k-iqr","text":"The k interquartile range is a used to compare a point against a distribution. It is defined as the distance of a given point from the median scaled by the interquartile range \\[ k = \\frac{Q_2 - x}{Q_3 - Q_1} \\] This metric is similar to the z-score but more robust to outliers.","title":"k-IQR"},{"location":"ipr/core_variants/expression/#percentile","text":"The percentile rank is a non-parametric way of measuring a given data point relative to the distribution.","title":"Percentile"},{"location":"ipr/core_variants/expression/#comparators","text":"All of the standard expression metrics in IPR are expected to be calculated against a reference distribution of expression samples. To this end, IPR provides a number of fields to record which distributions were used. This ensures that the final result is interperable and reproducible. A complete list of comparators can be found in the comparators section of the user manual. Expression comparators fall into three main groups: disease, primary site, and biopsy site.","title":"Comparators"},{"location":"ipr/core_variants/expression/#disease","text":"The reference distribution that most closely matches the diagnosis of the current sample","title":"Disease"},{"location":"ipr/core_variants/expression/#primary-site","text":"The reference distribution that most closely matches the non-diseased/normal expression of the primary site tissue","title":"Primary Site"},{"location":"ipr/core_variants/expression/#biopsy-site","text":"The reference distribution that most closely matches the non-diseased/normal expression of the biopsy site tissue. This is important for metastatic samples where the biopsy site and primary site differ.","title":"Biopsy Site"},{"location":"ipr/core_variants/expression/#images","text":"The use can optionally include expression density plots to allow the user to view the relative expression of the current sample compared to a specific distribution. Info These will be passed to the report upload function via the images section of the JSON input key: expDensity\\.(\\S+) In the above the pattern is expected to be expDensity.<gene name> where the gene name matches the gene name(s) used for the expression variant definitions. Where these plots are included for the genes listed as variants they will be shown along with the expression data in the expression variants section. In the interface these will appear in the actions tab where available. This will bring up the expression density plot in a popup","title":"Images"},{"location":"ipr/core_variants/mutations/","text":"Small Mutations Small mutations are composed of indels and single nucleotide variants. These should be passed to the IPR python adaptor in the main report content JSON. { \"smallMutations\" : [ // varia nts ] } Each variant is an object which may contain any of the following fields Field Type Example Description altSeq (required) string \"C\" the alternate sequence chromosome (required) string \"X\" the chromosome this mutation is located on endPosition (required) integer 1234 the genomic end poition of this variant gene (required) string \"KRAS\" the gene name proteinChange (required) string? \"p.G12D\" the HGVS protein notation. Can also be the cds or genomic notation for variants where there is no equivalent protein notation. Protein notation is preferred. refSeq (required) string? \"A\" the reference sequence startPosition (required) integer 1234 the genomic start position of this variant transcript (required) string? \"ENST00001.2\" the transcript name detectedIn string \"DNA/RNA\" the sample types this variant was detected in hgvsCds string? \"ENST0001:c.1234+3A>G\" HGVS coding sequence notation for this variant hgvsGenomic string? \"1:g.1234A>G\" HGVS genomic notation for this variant hgvsProtein string? \"KRAS:p.G12D\" HGVS protein notation for this variant ncbiBuild string? \"GRCh37\" the genome reference assembly build version normalAltCount integer? 1 the number of alternate reads in the normal genome supporting the mutation normalDepth integer? 1 the total number of reads at this position in the normal genome normalRefCount integer? 1 the number of reference reads in the normal genome rnaAltCount integer? 1 the number of alternate reads in the rna supporting the mutation rnaDepth integer? 2 the total number of reads at this position in the rna rnaRefCount integer? 1 the number of reference reads in the rna tumourAltCount integer? 1 the number of alternate reads in the tumour genome supporting the mutation tumourDepth integer? 2 the total number of reads at this position in the tumour genome, if not given this will be inferred based on the ref and alt count sum tumourRefCount integer? 1 the number of reference reads in the tumour genome zygosity string? \"het\"","title":"Small Mutations"},{"location":"ipr/core_variants/mutations/#small-mutations","text":"Small mutations are composed of indels and single nucleotide variants. These should be passed to the IPR python adaptor in the main report content JSON. { \"smallMutations\" : [ // varia nts ] } Each variant is an object which may contain any of the following fields Field Type Example Description altSeq (required) string \"C\" the alternate sequence chromosome (required) string \"X\" the chromosome this mutation is located on endPosition (required) integer 1234 the genomic end poition of this variant gene (required) string \"KRAS\" the gene name proteinChange (required) string? \"p.G12D\" the HGVS protein notation. Can also be the cds or genomic notation for variants where there is no equivalent protein notation. Protein notation is preferred. refSeq (required) string? \"A\" the reference sequence startPosition (required) integer 1234 the genomic start position of this variant transcript (required) string? \"ENST00001.2\" the transcript name detectedIn string \"DNA/RNA\" the sample types this variant was detected in hgvsCds string? \"ENST0001:c.1234+3A>G\" HGVS coding sequence notation for this variant hgvsGenomic string? \"1:g.1234A>G\" HGVS genomic notation for this variant hgvsProtein string? \"KRAS:p.G12D\" HGVS protein notation for this variant ncbiBuild string? \"GRCh37\" the genome reference assembly build version normalAltCount integer? 1 the number of alternate reads in the normal genome supporting the mutation normalDepth integer? 1 the total number of reads at this position in the normal genome normalRefCount integer? 1 the number of reference reads in the normal genome rnaAltCount integer? 1 the number of alternate reads in the rna supporting the mutation rnaDepth integer? 2 the total number of reads at this position in the rna rnaRefCount integer? 1 the number of reference reads in the rna tumourAltCount integer? 1 the number of alternate reads in the tumour genome supporting the mutation tumourDepth integer? 2 the total number of reads at this position in the tumour genome, if not given this will be inferred based on the ref and alt count sum tumourRefCount integer? 1 the number of reference reads in the tumour genome zygosity string? \"het\"","title":"Small Mutations"},{"location":"ipr/core_variants/structural/","text":"Structural Variants Structural variants should be passed to the IPR python adaptor in the main report content JSON. { \"structuralVariants\" : [ // varia nts ] } Each variant is an object which may contain any of the following fields Field Type Example Description breakpoint (required) string \"12:123456|14:1244662\" description of the breakpoints involved in this structural variant eventType (required) string \"deletion\" the type of underlying structural variant exon1 (required) integer? 1 the 5' (n-terminal) exon exon2 (required) integer? 2 the 3' (c-terminal) exon gene1 (required) string \"EWSR1\" the 5' (n-terminal) gene name gene2 (required) string \"FLI1\" the 3' (c-terminal) gene name cTermTranscript string? \"ENST0004.5\" the 5' transcript name conventionalName string cytogenetic descriptor detectedIn string \"DNA\" the sample type(s) this SV was detected in highQuality boolean? This structural variant has a high level of supporting evidence nTermTranscript string? \"ENST0001.2\" the 3' transcript name omicSupport boolean flag to indicate this SV has supprt from both genome and transcriptome svg string? svg image file content for this SV svgTitle string? The title to accompany this SV Images When the svg field contains an SVG image string this image will be displayed by the report via the actions tab (see button circled in red below). This allows the user to bring up the visualization when they are reviewing the structural variants in the report. Clicking this button will bring the user to a pop up showing the visualization. The visualization shown below was created with MAVIS .","title":"Structural Variants"},{"location":"ipr/core_variants/structural/#structural-variants","text":"Structural variants should be passed to the IPR python adaptor in the main report content JSON. { \"structuralVariants\" : [ // varia nts ] } Each variant is an object which may contain any of the following fields Field Type Example Description breakpoint (required) string \"12:123456|14:1244662\" description of the breakpoints involved in this structural variant eventType (required) string \"deletion\" the type of underlying structural variant exon1 (required) integer? 1 the 5' (n-terminal) exon exon2 (required) integer? 2 the 3' (c-terminal) exon gene1 (required) string \"EWSR1\" the 5' (n-terminal) gene name gene2 (required) string \"FLI1\" the 3' (c-terminal) gene name cTermTranscript string? \"ENST0004.5\" the 5' transcript name conventionalName string cytogenetic descriptor detectedIn string \"DNA\" the sample type(s) this SV was detected in highQuality boolean? This structural variant has a high level of supporting evidence nTermTranscript string? \"ENST0001.2\" the 3' transcript name omicSupport boolean flag to indicate this SV has supprt from both genome and transcriptome svg string? svg image file content for this SV svgTitle string? The title to accompany this SV","title":"Structural Variants"},{"location":"ipr/core_variants/structural/#images","text":"When the svg field contains an SVG image string this image will be displayed by the report via the actions tab (see button circled in red below). This allows the user to bring up the visualization when they are reviewing the structural variants in the report. Clicking this button will bring the user to a pop up showing the visualization. The visualization shown below was created with MAVIS .","title":"Images"},{"location":"ipr/optional_analyses/burden/","text":"Mutation Burden Data Measure of the relative counts of various types of mutations compared to those from a given cohort of samples. The \"role\" determines with comparator these values are calculated in reference to { \"mutationBurden\" : [ { \"snv\" : 4 , \"snvTruncating\" : 0 , \"indels\" : 0 , \"indelsFrameshift\" : 0 , \"sv\" : 92 , \"svExpressed\" : 40 , \"snvPercentile\" : 4 , \"indelPercentile\" : 10 , \"svPercentile\" : 60 , \"role\" : \"primary\" } ], } Field Type Example Description role (required) string indelPercentile number 1 Percentile of the count of indels in the current sample relative to a reference distribution indels integer Absolute number of indels in the current sample indelsFrameshift integer Absolute number of indels which result in a frameshift in the current sample snv integer Absolute number of single nucleotide variants in the current sample snvPercentile number Percentile of the count of single nucleotide variants in the current sample relative to a reference distribution snvTruncating integer Absolute number of single nucleotide variants which are truncating in the current sample sv integer Absolute number of structural variants in the current sample svExpressed integer Absolute number of expressed (support in RNA) structural variants in the current sample svPercentile number Percentile of the count of structural variants in the current sample relative to a reference distribution Comparators and Roles The role used by the mutation burden data is linked to the mutation burden images in the report that is created by the comparators input . The images use the following key: mutationBurden\\.(barplot|density|legend)_(sv|snv|indel)\\.(primary|secondary|tertiary|quaternary) which maps to the comparators mutation burden (primary) mutation burden (secondary) mutation burden (tertiary) mutation burden (quaternary) Therefore for a complete mutation burden entry one might see the following { \"mutationBurden\" : [ { \"snv\" : 4 , \"snvTruncating\" : 0 , \"indels\" : 0 , \"indelsFrameshift\" : 0 , \"sv\" : 92 , \"svExpressed\" : 40 , \"snvPercentile\" : 4 , \"indelPercentile\" : 10 , \"svPercentile\" : 60 , \"role\" : \"primary\" } ], \"comparators\" : [ { \"analysisRole\" : \"mutation burden (primary)\" , \"name\" : \"TCGA COAD\" } ], \"images\" : [ { \"key\" : \"mutationBurden.barplot_snv.primary\" , \"path\" : \"/path/to/image/file.png\" }, { \"key\" : \"mutationBurden.legend_snv.primary\" , \"path\" : \"/path/to/other/image/file.png\" }, { \"key\" : \"mutationBurden.density_snv.primary\" , \"path\" : \"/path/to/other-other/image/file.png\" } ] } Note that the above only loaded images for the SNVs but similar images would be expected for SVs and indels. Images A number of images can optionally be included and will be displayed in the mutation burden section of the report. These are summary images which represent the count of a variant type in the current report relative to the counts of samples in the reference distribution (based on the comparators listed above). These images are generated by the user prior to creating the report. full pattern: mutationBurden\\.(barplot|density|legend)_(sv|snv|indel)\\.(primary|secondary|tertiary|quaternary) SNVs key: mutationBurden\\.density_snv\\.(primary|secondary|tertiary|quaternary) key: mutationBurden\\.barplot_snv\\.(primary|secondary|tertiary|quaternary) key: mutationBurden\\.density_indel\\.(primary|secondary|tertiary|quaternary) Indels key: mutationBurden\\.barplot_indel\\.(primary|secondary|tertiary|quaternary) Structural Variants key: mutationBurden\\.density_sv\\.(primary|secondary|tertiary|quaternary) SV-specific Comparator Overloading There are special overload comparators for stuctural variants since they often have a different comparator dataset from the SNV and Indels. Specifying an SV specific comparator will overload the more general comparator for the SV types mutation burden SV (primary) mutation burden SV (secondary) mutation burden SV (tertiary) mutation burden SV (quaternary) This means that when the report client lists the comparator that corresponds to the images and data it will use the SV-specific value where it exists instead of the more general comparator name.","title":"Mutation Burden"},{"location":"ipr/optional_analyses/burden/#mutation-burden","text":"","title":"Mutation Burden"},{"location":"ipr/optional_analyses/burden/#data","text":"Measure of the relative counts of various types of mutations compared to those from a given cohort of samples. The \"role\" determines with comparator these values are calculated in reference to { \"mutationBurden\" : [ { \"snv\" : 4 , \"snvTruncating\" : 0 , \"indels\" : 0 , \"indelsFrameshift\" : 0 , \"sv\" : 92 , \"svExpressed\" : 40 , \"snvPercentile\" : 4 , \"indelPercentile\" : 10 , \"svPercentile\" : 60 , \"role\" : \"primary\" } ], } Field Type Example Description role (required) string indelPercentile number 1 Percentile of the count of indels in the current sample relative to a reference distribution indels integer Absolute number of indels in the current sample indelsFrameshift integer Absolute number of indels which result in a frameshift in the current sample snv integer Absolute number of single nucleotide variants in the current sample snvPercentile number Percentile of the count of single nucleotide variants in the current sample relative to a reference distribution snvTruncating integer Absolute number of single nucleotide variants which are truncating in the current sample sv integer Absolute number of structural variants in the current sample svExpressed integer Absolute number of expressed (support in RNA) structural variants in the current sample svPercentile number Percentile of the count of structural variants in the current sample relative to a reference distribution","title":"Data"},{"location":"ipr/optional_analyses/burden/#comparators-and-roles","text":"The role used by the mutation burden data is linked to the mutation burden images in the report that is created by the comparators input . The images use the following key: mutationBurden\\.(barplot|density|legend)_(sv|snv|indel)\\.(primary|secondary|tertiary|quaternary) which maps to the comparators mutation burden (primary) mutation burden (secondary) mutation burden (tertiary) mutation burden (quaternary) Therefore for a complete mutation burden entry one might see the following { \"mutationBurden\" : [ { \"snv\" : 4 , \"snvTruncating\" : 0 , \"indels\" : 0 , \"indelsFrameshift\" : 0 , \"sv\" : 92 , \"svExpressed\" : 40 , \"snvPercentile\" : 4 , \"indelPercentile\" : 10 , \"svPercentile\" : 60 , \"role\" : \"primary\" } ], \"comparators\" : [ { \"analysisRole\" : \"mutation burden (primary)\" , \"name\" : \"TCGA COAD\" } ], \"images\" : [ { \"key\" : \"mutationBurden.barplot_snv.primary\" , \"path\" : \"/path/to/image/file.png\" }, { \"key\" : \"mutationBurden.legend_snv.primary\" , \"path\" : \"/path/to/other/image/file.png\" }, { \"key\" : \"mutationBurden.density_snv.primary\" , \"path\" : \"/path/to/other-other/image/file.png\" } ] } Note that the above only loaded images for the SNVs but similar images would be expected for SVs and indels.","title":"Comparators and Roles"},{"location":"ipr/optional_analyses/burden/#images","text":"A number of images can optionally be included and will be displayed in the mutation burden section of the report. These are summary images which represent the count of a variant type in the current report relative to the counts of samples in the reference distribution (based on the comparators listed above). These images are generated by the user prior to creating the report. full pattern: mutationBurden\\.(barplot|density|legend)_(sv|snv|indel)\\.(primary|secondary|tertiary|quaternary)","title":"Images"},{"location":"ipr/optional_analyses/burden/#snvs","text":"key: mutationBurden\\.density_snv\\.(primary|secondary|tertiary|quaternary) key: mutationBurden\\.barplot_snv\\.(primary|secondary|tertiary|quaternary) key: mutationBurden\\.density_indel\\.(primary|secondary|tertiary|quaternary)","title":"SNVs"},{"location":"ipr/optional_analyses/burden/#indels","text":"key: mutationBurden\\.barplot_indel\\.(primary|secondary|tertiary|quaternary)","title":"Indels"},{"location":"ipr/optional_analyses/burden/#structural-variants","text":"key: mutationBurden\\.density_sv\\.(primary|secondary|tertiary|quaternary)","title":"Structural Variants"},{"location":"ipr/optional_analyses/burden/#sv-specific-comparator-overloading","text":"There are special overload comparators for stuctural variants since they often have a different comparator dataset from the SNV and Indels. Specifying an SV specific comparator will overload the more general comparator for the SV types mutation burden SV (primary) mutation burden SV (secondary) mutation burden SV (tertiary) mutation burden SV (quaternary) This means that when the report client lists the comparator that corresponds to the images and data it will use the SV-specific value where it exists instead of the more general comparator name.","title":"SV-specific Comparator Overloading"},{"location":"ipr/optional_analyses/circos_plots/","text":"Circos Plots There are a number of fields for including circos plots in the report. Circos plots are a useful way to look at an overview of variants for a particular sample. Info These will be passed to the report upload function via the images section of the JSON input Copy Number Circos Plot key: cnvLoh.circos This plot will be included in the copy variants section of the report Structural Variant Circos Plots keys: circosSv.genome , circosSv.transcriptome These plots will be included in the structural variants section of the report Microbial Integration Circos Plots keys: microbial.circos.genome , microbial.circos.transcriptome This plot has its own section, along with the microbial integration fields. It is generally used to describe viral genome integration such as HPV16.","title":"Circos Plots"},{"location":"ipr/optional_analyses/circos_plots/#circos-plots","text":"There are a number of fields for including circos plots in the report. Circos plots are a useful way to look at an overview of variants for a particular sample. Info These will be passed to the report upload function via the images section of the JSON input","title":"Circos Plots"},{"location":"ipr/optional_analyses/circos_plots/#copy-number-circos-plot","text":"key: cnvLoh.circos This plot will be included in the copy variants section of the report","title":"Copy Number Circos Plot"},{"location":"ipr/optional_analyses/circos_plots/#structural-variant-circos-plots","text":"keys: circosSv.genome , circosSv.transcriptome These plots will be included in the structural variants section of the report","title":"Structural Variant Circos Plots"},{"location":"ipr/optional_analyses/circos_plots/#microbial-integration-circos-plots","text":"keys: microbial.circos.genome , microbial.circos.transcriptome This plot has its own section, along with the microbial integration fields. It is generally used to describe viral genome integration such as HPV16.","title":"Microbial Integration Circos Plots"},{"location":"ipr/optional_analyses/comparators/","text":"Comparators This is used to provide details on how outlier evaluations were performed by listing the cohorts that were used in the comparisons { \"comparators\" : [ { \"analysisRole\" : \"mutation burden (primary)\" , \"name\" : \"average\" }, { \"analysisRole\" : \"expression (disease QC)\" , \"name\" : \"qc_tcga_comp_TARGET_RHD_percentile_median_(6)\" , \"size\" : 6 }, { \"analysisRole\" : \"expression (primary site)\" , \"name\" : \"average\" , \"size\" : 1024 } ], } Field Type Example Description analysisRole (required) string key indicating which analysis this comparator was used for name (required) string \"TCGA BRCA\" comparator name size number the number of samples included in the cohort/reference distribution The field analysisRole can have the following values, each can only be used once per report cibersort (primary) cibersort (secondary) mixcr (primary) mixcr (secondary) HRD (primary) HRD (secondary) expression (disease) expression (disease QC) expression (primary site) expression (primary site QC) expression (biopsy site) expression (biopsy site QC) mutation burden (primary) mutation burden (secondary) mutation burden (tertiary) mutation burden (quaternary) mutation burden SV (primary) mutation burden SV (secondary) mutation burden SV (tertiary) mutation burden SV (quaternary) protein expression (primary) protein expression (secondary)","title":"Comparators"},{"location":"ipr/optional_analyses/comparators/#comparators","text":"This is used to provide details on how outlier evaluations were performed by listing the cohorts that were used in the comparisons { \"comparators\" : [ { \"analysisRole\" : \"mutation burden (primary)\" , \"name\" : \"average\" }, { \"analysisRole\" : \"expression (disease QC)\" , \"name\" : \"qc_tcga_comp_TARGET_RHD_percentile_median_(6)\" , \"size\" : 6 }, { \"analysisRole\" : \"expression (primary site)\" , \"name\" : \"average\" , \"size\" : 1024 } ], } Field Type Example Description analysisRole (required) string key indicating which analysis this comparator was used for name (required) string \"TCGA BRCA\" comparator name size number the number of samples included in the cohort/reference distribution The field analysisRole can have the following values, each can only be used once per report cibersort (primary) cibersort (secondary) mixcr (primary) mixcr (secondary) HRD (primary) HRD (secondary) expression (disease) expression (disease QC) expression (primary site) expression (primary site QC) expression (biopsy site) expression (biopsy site QC) mutation burden (primary) mutation burden (secondary) mutation burden (tertiary) mutation burden (quaternary) mutation burden SV (primary) mutation burden SV (secondary) mutation burden SV (tertiary) mutation burden SV (quaternary) protein expression (primary) protein expression (secondary)","title":"Comparators"},{"location":"ipr/optional_analyses/expression_correlation/","text":"Expression Correlation Comparator-Based Plot keys: expression.chart , expression.legend Info These will be passed to the report upload function via the images section of the JSON input This plot represents the pairwise correlation of the RNA expression of the current sample against samples from a variety of reference distributions. Often this is used as a sanity check of the diagnosis. It is expected that the sample should correlate most highly with other samples within the disease distribution that is most closely related to the diagnosis. It is also expected that samples with a lower tumour content/purity may show correlation with their biopsy site. Subtyping Plots These plots are similar to the main comparator based plots but are generally smaller and include only a set of subtypes of a specific cancer type (ex. BRCA). key: subtypePlot\\.\\S+ Pairwise RNA Expression Correlation Provide a list of the most similar other samples with respect to the RNA expression profile. { \"pairwiseExpressionCorrelation\" : [ { \"patientId\" : \"UPLOADPAT02\" , \"library\" : \"LIB0002\" , \"correlation\" : 0.99 , \"tumourType\" : \"pancreatic cancer\" , \"tissueType\" : \"liver\" , \"tumourContent\" : 15 } ] } All values expect the correlation are attributes of the sample being compared to and not the sample the report is being generated for Field Type Example Description correlation number 0.99 The RNA correlation between this sample and the report sample library string \"LIB002\" The library name of this sample patientId string \"UPLOADPAT02\" The patient ID of this sample tissueType string \"liver\" tumourContent number 15 the tumour content or purity of this sample tumourType string \"pancreatic cancer\" the diagnosis of this sample","title":"Expression Correlation"},{"location":"ipr/optional_analyses/expression_correlation/#expression-correlation","text":"","title":"Expression Correlation"},{"location":"ipr/optional_analyses/expression_correlation/#comparator-based-plot","text":"keys: expression.chart , expression.legend Info These will be passed to the report upload function via the images section of the JSON input This plot represents the pairwise correlation of the RNA expression of the current sample against samples from a variety of reference distributions. Often this is used as a sanity check of the diagnosis. It is expected that the sample should correlate most highly with other samples within the disease distribution that is most closely related to the diagnosis. It is also expected that samples with a lower tumour content/purity may show correlation with their biopsy site.","title":"Comparator-Based Plot"},{"location":"ipr/optional_analyses/expression_correlation/#subtyping-plots","text":"These plots are similar to the main comparator based plots but are generally smaller and include only a set of subtypes of a specific cancer type (ex. BRCA). key: subtypePlot\\.\\S+","title":"Subtyping Plots"},{"location":"ipr/optional_analyses/expression_correlation/#pairwise-rna-expression-correlation","text":"Provide a list of the most similar other samples with respect to the RNA expression profile. { \"pairwiseExpressionCorrelation\" : [ { \"patientId\" : \"UPLOADPAT02\" , \"library\" : \"LIB0002\" , \"correlation\" : 0.99 , \"tumourType\" : \"pancreatic cancer\" , \"tissueType\" : \"liver\" , \"tumourContent\" : 15 } ] } All values expect the correlation are attributes of the sample being compared to and not the sample the report is being generated for Field Type Example Description correlation number 0.99 The RNA correlation between this sample and the report sample library string \"LIB002\" The library name of this sample patientId string \"UPLOADPAT02\" The patient ID of this sample tissueType string \"liver\" tumourContent number 15 the tumour content or purity of this sample tumourType string \"pancreatic cancer\" the diagnosis of this sample","title":"Pairwise RNA Expression Correlation"},{"location":"ipr/optional_analyses/images/","text":"Images There are a number of images that can be uploaded to the report. Images require a path to the image and the key for the image. The image key is used to tell IPR how to place the image in the report. The following are examples with their expected format and image key. { \"images\" : [ { \"key\" : \"string\" , \"path\" : \"/path/to/image/file\" , \"title\" : \"\" , \"caption\" : \"\" } ] }","title":"Images"},{"location":"ipr/optional_analyses/images/#images","text":"There are a number of images that can be uploaded to the report. Images require a path to the image and the key for the image. The image key is used to tell IPR how to place the image in the report. The following are examples with their expected format and image key. { \"images\" : [ { \"key\" : \"string\" , \"path\" : \"/path/to/image/file\" , \"title\" : \"\" , \"caption\" : \"\" } ] }","title":"Images"},{"location":"ipr/optional_analyses/immune/","text":"Immune Profiling OptiType (HLA Types) OptiType publication { \"hlaTypes\" : [ { \"pathology\" : \"normal\" , \"protocol\" : \"DNA\" , \"a1\" : \"A*02:03\" , \"a2\" : \"A*11:01\" , \"b1\" : \"B*40:01\" , \"b2\" : \"B*38:02\" , \"c1\" : \"C*07:02\" , \"c2\" : \"C*07:02\" } ] } Field Type Example Description a1 string \"A*02:03\" a2 string \"A*11:01\" b1 string \"B*40:01\" b2 string \"B*38:02\" c1 string \"C*07:02\" c2 string \"C*07:02\" pathology string \"normal\" the disease state of this sample protocol string \"DNA\" the sequencing protocol used for ths sample Cibersort (Immune Cell Types) Cibersort publication { \"immuneCellTypes\" : { \"cellType\" : \"combined T cell\" , \"kbCategory\" : \"moderate\" , \"score\" : 76 , \"percentile\" : 50 } } Field Type Example Description cellType (required) string \"combined T cell\" kbCategory string \"moderate\" percentile number 50 score number 76 Example cell type values are B cells naive B cells memory Plasma cells T cells CD8 T cells CD4 naive T cells CD4 memory resting T cells CD4 memory activated T cells follicular helper T cells regulatory (Tregs) T cells gamma delta NK cells resting NK cells activated Monocytes Macrophages M0 Macrophages M1 Macrophages M2 Dendritic cells resting Dendritic cells activated Mast cells resting Mast cells activated Eosinophils Neutrophils T.cell.inflitration Cibersort Images Info These will be passed to the report upload function via the images section of the JSON input key: cibersort.cd8_positive_t-cell_scatter key: cibersort.combined_t-cell_scatter MiXCR Info These will be passed to the report upload function via the images section of the JSON input MiXCR Publication key: mixcr.circos_trb_vj_gene_usage key: mixcr.dominance_vs_alpha_beta_t-cells_scatter","title":"Immune Profiling"},{"location":"ipr/optional_analyses/immune/#immune-profiling","text":"","title":"Immune Profiling"},{"location":"ipr/optional_analyses/immune/#optitype-hla-types","text":"OptiType publication { \"hlaTypes\" : [ { \"pathology\" : \"normal\" , \"protocol\" : \"DNA\" , \"a1\" : \"A*02:03\" , \"a2\" : \"A*11:01\" , \"b1\" : \"B*40:01\" , \"b2\" : \"B*38:02\" , \"c1\" : \"C*07:02\" , \"c2\" : \"C*07:02\" } ] } Field Type Example Description a1 string \"A*02:03\" a2 string \"A*11:01\" b1 string \"B*40:01\" b2 string \"B*38:02\" c1 string \"C*07:02\" c2 string \"C*07:02\" pathology string \"normal\" the disease state of this sample protocol string \"DNA\" the sequencing protocol used for ths sample","title":"OptiType (HLA Types)"},{"location":"ipr/optional_analyses/immune/#cibersort-immune-cell-types","text":"Cibersort publication { \"immuneCellTypes\" : { \"cellType\" : \"combined T cell\" , \"kbCategory\" : \"moderate\" , \"score\" : 76 , \"percentile\" : 50 } } Field Type Example Description cellType (required) string \"combined T cell\" kbCategory string \"moderate\" percentile number 50 score number 76 Example cell type values are B cells naive B cells memory Plasma cells T cells CD8 T cells CD4 naive T cells CD4 memory resting T cells CD4 memory activated T cells follicular helper T cells regulatory (Tregs) T cells gamma delta NK cells resting NK cells activated Monocytes Macrophages M0 Macrophages M1 Macrophages M2 Dendritic cells resting Dendritic cells activated Mast cells resting Mast cells activated Eosinophils Neutrophils T.cell.inflitration","title":"Cibersort (Immune Cell Types)"},{"location":"ipr/optional_analyses/immune/#cibersort-images","text":"Info These will be passed to the report upload function via the images section of the JSON input key: cibersort.cd8_positive_t-cell_scatter key: cibersort.combined_t-cell_scatter","title":"Cibersort Images"},{"location":"ipr/optional_analyses/immune/#mixcr","text":"Info These will be passed to the report upload function via the images section of the JSON input MiXCR Publication key: mixcr.circos_trb_vj_gene_usage key: mixcr.dominance_vs_alpha_beta_t-cells_scatter","title":"MiXCR"},{"location":"ipr/optional_analyses/metadata/","text":"Patient Metadata { \"patientInformation\" : { \"age\" : \"\" , \"biopsySite\" : \"Description of biopsy site\" , \"caseType\" : \"Adult\" , \"constitutionalProtocol\" : \"WGS\" , \"constitutionalSample\" : \"Blood-Peripheral\" , \"diagnosis\" : \"patient disease diagnosis\" , \"gender\" : \"Male\" , \"physician\" : \"Dr. Who\" , \"tumourProtocol\" : \"WGS/RNA-Seq\" , \"tumourSample\" : \"Metastatic\" } } The patient information fields are listed in detail below Field Type Example Description age string biopsySite string description of the biopsy site location caseType string \"Adult\" constitutionalProtocol string \"WGS\" constitutionalSample string \"Blood-Peripheral\" diagnosis string The patient disease diagnosis gender string \"Male\" physician string \"Dr. Who\" the treating (or enrolling) physician for the current patient tumourProtocol string \"WGS/RNA-seq\" tumourSample string \"Metastatic\"","title":"Patient Metadata"},{"location":"ipr/optional_analyses/metadata/#patient-metadata","text":"{ \"patientInformation\" : { \"age\" : \"\" , \"biopsySite\" : \"Description of biopsy site\" , \"caseType\" : \"Adult\" , \"constitutionalProtocol\" : \"WGS\" , \"constitutionalSample\" : \"Blood-Peripheral\" , \"diagnosis\" : \"patient disease diagnosis\" , \"gender\" : \"Male\" , \"physician\" : \"Dr. Who\" , \"tumourProtocol\" : \"WGS/RNA-Seq\" , \"tumourSample\" : \"Metastatic\" } } The patient information fields are listed in detail below Field Type Example Description age string biopsySite string description of the biopsy site location caseType string \"Adult\" constitutionalProtocol string \"WGS\" constitutionalSample string \"Blood-Peripheral\" diagnosis string The patient disease diagnosis gender string \"Male\" physician string \"Dr. Who\" the treating (or enrolling) physician for the current patient tumourProtocol string \"WGS/RNA-seq\" tumourSample string \"Metastatic\"","title":"Patient Metadata"},{"location":"ipr/optional_analyses/signature/","text":"Mutation Signatures These are the scores of individual mutation signatures . These can include cosmic and/or custom signatures. The nnls field is the non-negative least squares contribution of the given signature { \"mutationSignature\" : [ { \"signature\" : \"SBS1\" , \"nnls\" : 0.344 , \"associations\" : \"Tobacco chewing\" , \"features\" : \"D,T\" , \"numCancerTypes\" : 1 , \"cancerTypes\" : \"stomach cancer\" , \"selected\" : false , \"kbCategory\" : \"strong signature\" } ] } Field Type Example Description signature (required) string \"SBS1\" name of the signature associations string \"Tobacco chewing\" known behaviours, processes, or phenotypes that are associated with the current signature cancerTypes string \"stomach cancer\" features string \"D,T\" kbCategory string \"strong signature\" The kb category will be used to create a categorical verion of the signature variant which can be matched and annotated against GraphKB nnls number 0.344 non-negative lease squares numCancerTypes integer 1 selected boolean false Flag used to determine if this signature should be highlight on the main summary page of the report The selected field indicates if this signature should be shown on the front page of the report or not. This field can be toggled via the client interface following upload. Images Info These will be passed to the report upload function via the images section of the JSON input key: mutSignature.barplot.sbs key: mutSignature.barplot.dbs key: mutSignature.barplot.indels","title":"Mutation Signatures"},{"location":"ipr/optional_analyses/signature/#mutation-signatures","text":"These are the scores of individual mutation signatures . These can include cosmic and/or custom signatures. The nnls field is the non-negative least squares contribution of the given signature { \"mutationSignature\" : [ { \"signature\" : \"SBS1\" , \"nnls\" : 0.344 , \"associations\" : \"Tobacco chewing\" , \"features\" : \"D,T\" , \"numCancerTypes\" : 1 , \"cancerTypes\" : \"stomach cancer\" , \"selected\" : false , \"kbCategory\" : \"strong signature\" } ] } Field Type Example Description signature (required) string \"SBS1\" name of the signature associations string \"Tobacco chewing\" known behaviours, processes, or phenotypes that are associated with the current signature cancerTypes string \"stomach cancer\" features string \"D,T\" kbCategory string \"strong signature\" The kb category will be used to create a categorical verion of the signature variant which can be matched and annotated against GraphKB nnls number 0.344 non-negative lease squares numCancerTypes integer 1 selected boolean false Flag used to determine if this signature should be highlight on the main summary page of the report The selected field indicates if this signature should be shown on the front page of the report or not. This field can be toggled via the client interface following upload.","title":"Mutation Signatures"},{"location":"ipr/optional_analyses/signature/#images","text":"Info These will be passed to the report upload function via the images section of the JSON input key: mutSignature.barplot.sbs key: mutSignature.barplot.dbs key: mutSignature.barplot.indels","title":"Images"},{"location":"variant_notation/","text":"About The variant notation is a shorthand to make it faster to enter/display variants. It is made up of two forms: continuous , and multi-feature . Most people will be more familiar with the continuous notation. It is based on HGVS v15.11 and can be used to describe any variant that has only a single reference feature (i.e. KRAS). Multi-feature notation is required when one needs to describe any variant involving multiple reference features. This could be something like a gene fusion where the reference features might be EWSR1, and FLI1. Warning The notation examples included in this documentation do not necessarily represent actual mutations. While they are all valid syntax, no attempt has been made to check that the sequences given are correct General Notation Prefixes Both forms of notation can be described as two breakpoints and an event type. Some may also include reference sequence and untemplated sequence descriptions. Additionally both forms will use a common prefix notation. These prefixes are described under coordinate systems Variant Types The expected variant types are given below. Some types are only applicable to certain coordinate systems (i.e. frameshifts are protein only). Variant Type Description Standard HGVS Prefix Specific > substitutions \u2714 g / c / r / n del deletions \u2714 delins indels \u2714 dup duplications \u2714 fs frameshifts \u2714 p ext extensions \u2714 p ins insertions \u2714 inv inversions \u2714 fusion gene fusion trans translocation itrans inverted translocation mut non-specific mutation spl splice site mutation p mis missense mutation p Unsupported HGVS Features There are a few elements of the HGVS v15.11 notation that are not yet supported ( contributions are welcome! ). These include: mosacism chimerism RNA variants conversions alleles v20 Complex Variants","title":"About"},{"location":"variant_notation/#about","text":"The variant notation is a shorthand to make it faster to enter/display variants. It is made up of two forms: continuous , and multi-feature . Most people will be more familiar with the continuous notation. It is based on HGVS v15.11 and can be used to describe any variant that has only a single reference feature (i.e. KRAS). Multi-feature notation is required when one needs to describe any variant involving multiple reference features. This could be something like a gene fusion where the reference features might be EWSR1, and FLI1. Warning The notation examples included in this documentation do not necessarily represent actual mutations. While they are all valid syntax, no attempt has been made to check that the sequences given are correct","title":"About"},{"location":"variant_notation/#general-notation","text":"","title":"General Notation"},{"location":"variant_notation/#prefixes","text":"Both forms of notation can be described as two breakpoints and an event type. Some may also include reference sequence and untemplated sequence descriptions. Additionally both forms will use a common prefix notation. These prefixes are described under coordinate systems","title":"Prefixes"},{"location":"variant_notation/#variant-types","text":"The expected variant types are given below. Some types are only applicable to certain coordinate systems (i.e. frameshifts are protein only). Variant Type Description Standard HGVS Prefix Specific > substitutions \u2714 g / c / r / n del deletions \u2714 delins indels \u2714 dup duplications \u2714 fs frameshifts \u2714 p ext extensions \u2714 p ins insertions \u2714 inv inversions \u2714 fusion gene fusion trans translocation itrans inverted translocation mut non-specific mutation spl splice site mutation p mis missense mutation p","title":"Variant Types"},{"location":"variant_notation/#unsupported-hgvs-features","text":"There are a few elements of the HGVS v15.11 notation that are not yet supported ( contributions are welcome! ). These include: mosacism chimerism RNA variants conversions alleles v20 Complex Variants","title":"Unsupported HGVS Features"},{"location":"variant_notation/continuous/","text":"Continuous Notation All continuous notation follows a similar pattern that is loosely defined as: <feature>:<prefix>.<pos><type><seq> The reference feature would be the gene (chromosome, transcript, etc.) name that the variant occurs on. The prefix denotes the coordinate type (see prefixes ). The range is the position or positions of the variant. For a deletion, this is the range that is deleted. For an insertion, this is the two positions the sequence is inserted between. The sequence element will depend on the type of variant being described, but often this is the untemplated/inserted sequence. The sequence element is often optional. For all notation types there are general and more specific versions of notating the same event. Where possible more specificity is preferred. But it is recognized that notation coming from outside sources may not always provide all information. For each variant, the different equivalent notation options are shown below in order of increasing specificity. Examples Substitution Genomic/CDS substitution variants differ from protein substitution variants . Therefore examples of both will be given. A protein missense mutation where G is replaced with D KRAS:p.G12D A genomic substitution from A to C chr11:g.1234A>C Indel A protein deletion of amino acids GH and insertion of three amino acids TTA EGFR:p.G512_H513delins EGFR:p.G512_H513delins3 EGFR:p.G512_H513delGHins EGFR:p.G512_H513delGHins3 EGFR:p.G512_H513delinsTTA EGFR:p.G512_H513delGHinsTTA Insertion Insertions must be a range to specify between which two coordinates the insertion occurs. This avoids the problem when only a single coordinate is given of which side it is inserted on. An protein insertion of four amino acids between G123 and H124. The sequence element here is optional and can also be described as a number if the number of bases inserted is known but the sequence is not given. EGFR:p.G123_H124ins EGFR:p.G123_H124ins4 EGFR:p.G123_H124insCCST Deletion The reference sequence is optional when denoting a deletion. For example the same deletion could be notated both ways as shown below. EGFR:p.R10_G14del EGFR:p.R10_G14del5 EGFR:p.R10_G14delRSTGG If the reference sequence is known, it is always better to provide more information than less. Duplication Four amino acids are duplicated. Once again, the sequence element is optional EGFR:p.R10_G14dup EGFR:p.R10_G14dup5 EGFR:p.R10_G14dupRSTGG Frameshift Frameshifts are only applicable to variants denoted with protein coordinates. Frameshift notation follows the pattern below <feature>:p.<pos><first alternate AA>fs*<position of next truncating AA> The first alternate AA , and position of next truncating AA are both optional elements. For example the protein frameshift variant might be noted multiple ways PTEN:p.G123fs PTEN:p.G123fs*10 PTEN:p.G123Afs PTEN:p.G123Afs*10","title":"Continuous Notation"},{"location":"variant_notation/continuous/#continuous-notation","text":"All continuous notation follows a similar pattern that is loosely defined as: <feature>:<prefix>.<pos><type><seq> The reference feature would be the gene (chromosome, transcript, etc.) name that the variant occurs on. The prefix denotes the coordinate type (see prefixes ). The range is the position or positions of the variant. For a deletion, this is the range that is deleted. For an insertion, this is the two positions the sequence is inserted between. The sequence element will depend on the type of variant being described, but often this is the untemplated/inserted sequence. The sequence element is often optional. For all notation types there are general and more specific versions of notating the same event. Where possible more specificity is preferred. But it is recognized that notation coming from outside sources may not always provide all information. For each variant, the different equivalent notation options are shown below in order of increasing specificity.","title":"Continuous Notation"},{"location":"variant_notation/continuous/#examples","text":"","title":"Examples"},{"location":"variant_notation/continuous/#substitution","text":"Genomic/CDS substitution variants differ from protein substitution variants . Therefore examples of both will be given. A protein missense mutation where G is replaced with D KRAS:p.G12D A genomic substitution from A to C chr11:g.1234A>C","title":"Substitution"},{"location":"variant_notation/continuous/#indel","text":"A protein deletion of amino acids GH and insertion of three amino acids TTA EGFR:p.G512_H513delins EGFR:p.G512_H513delins3 EGFR:p.G512_H513delGHins EGFR:p.G512_H513delGHins3 EGFR:p.G512_H513delinsTTA EGFR:p.G512_H513delGHinsTTA","title":"Indel"},{"location":"variant_notation/continuous/#insertion","text":"Insertions must be a range to specify between which two coordinates the insertion occurs. This avoids the problem when only a single coordinate is given of which side it is inserted on. An protein insertion of four amino acids between G123 and H124. The sequence element here is optional and can also be described as a number if the number of bases inserted is known but the sequence is not given. EGFR:p.G123_H124ins EGFR:p.G123_H124ins4 EGFR:p.G123_H124insCCST","title":"Insertion"},{"location":"variant_notation/continuous/#deletion","text":"The reference sequence is optional when denoting a deletion. For example the same deletion could be notated both ways as shown below. EGFR:p.R10_G14del EGFR:p.R10_G14del5 EGFR:p.R10_G14delRSTGG If the reference sequence is known, it is always better to provide more information than less.","title":"Deletion"},{"location":"variant_notation/continuous/#duplication","text":"Four amino acids are duplicated. Once again, the sequence element is optional EGFR:p.R10_G14dup EGFR:p.R10_G14dup5 EGFR:p.R10_G14dupRSTGG","title":"Duplication"},{"location":"variant_notation/continuous/#frameshift","text":"Frameshifts are only applicable to variants denoted with protein coordinates. Frameshift notation follows the pattern below <feature>:p.<pos><first alternate AA>fs*<position of next truncating AA> The first alternate AA , and position of next truncating AA are both optional elements. For example the protein frameshift variant might be noted multiple ways PTEN:p.G123fs PTEN:p.G123fs*10 PTEN:p.G123Afs PTEN:p.G123Afs*10","title":"Frameshift"},{"location":"variant_notation/split/","text":"Multi-Feature (Split) Notation Multi-feature notation is a novel feature of GraphKB-HGVS and not part of standard HGVS. It is based on the original form for cytogenetic descriptions of translocations (as previously reccommended by HGVS) but this form is generalized to allow other coordinate systems. Multi-Feature notation will use the same positions and coordinate systems as continuous notation. However parentheses are used to divide features and positions. All multi-feature variants should following the pattern below (<feature>,<feature>):<type>(<prefix>.<pos>,<prefix>.<pos>)<seq> Untemplated sequence should only be included for sequence specific coordinate types such as genomic, CDS, and protein. Where possible, continuous notation is preferred to multi-feature. Examples Gene Fusion Using exon coordinates we could describe a gene fusion of exon 4 of EWSR1 to exon 7 of FLI1 as follows (EWSR1,FLI1):fusion(e.4,e.7) A range can also be used here. When a range of positions is given it indicates uncertainty. Since the range is already separated by a comma it is not necessary to enclose the uncertainty in parentheses (as you would for continuous notation). For example, if we wanted to express a fusion of any exon from 4-6 of EWSR1 to any exon from 7-10 of FLI1 (ESWR1,FLI1):fusion(e.4_6,e.7_10) Genomic Translocation Multi-feature variants can also be described using the genomic coordinate system ( g ). For example a translocation might be described (chr8,chr7):trans(g.1234,g.4567) (chr8,chr7):trans(g.1234,g.4567)AAT Above we are describing a translocation from chr8:1234 to chr7:4567 where AAT is the untemplated sequence inserted between the breakpoints.","title":"Multi-Feature (Split) Notation"},{"location":"variant_notation/split/#multi-feature-split-notation","text":"Multi-feature notation is a novel feature of GraphKB-HGVS and not part of standard HGVS. It is based on the original form for cytogenetic descriptions of translocations (as previously reccommended by HGVS) but this form is generalized to allow other coordinate systems. Multi-Feature notation will use the same positions and coordinate systems as continuous notation. However parentheses are used to divide features and positions. All multi-feature variants should following the pattern below (<feature>,<feature>):<type>(<prefix>.<pos>,<prefix>.<pos>)<seq> Untemplated sequence should only be included for sequence specific coordinate types such as genomic, CDS, and protein. Where possible, continuous notation is preferred to multi-feature.","title":"Multi-Feature (Split) Notation"},{"location":"variant_notation/split/#examples","text":"","title":"Examples"},{"location":"variant_notation/split/#gene-fusion","text":"Using exon coordinates we could describe a gene fusion of exon 4 of EWSR1 to exon 7 of FLI1 as follows (EWSR1,FLI1):fusion(e.4,e.7) A range can also be used here. When a range of positions is given it indicates uncertainty. Since the range is already separated by a comma it is not necessary to enclose the uncertainty in parentheses (as you would for continuous notation). For example, if we wanted to express a fusion of any exon from 4-6 of EWSR1 to any exon from 7-10 of FLI1 (ESWR1,FLI1):fusion(e.4_6,e.7_10)","title":"Gene Fusion"},{"location":"variant_notation/split/#genomic-translocation","text":"Multi-feature variants can also be described using the genomic coordinate system ( g ). For example a translocation might be described (chr8,chr7):trans(g.1234,g.4567) (chr8,chr7):trans(g.1234,g.4567)AAT Above we are describing a translocation from chr8:1234 to chr7:4567 where AAT is the untemplated sequence inserted between the breakpoints.","title":"Genomic Translocation"},{"location":"variant_notation/coordinate_systems/","text":"About Notation forms will use a common prefix notation. These describe the units of any positions given in the variant description. For example, protein notation ( p. ) would have amino acids as units. Prefix Coordinate Type Standard HGVS g Genomic \u2714 c Coding reference sequence (CDS) \u2714 p Protein \u2714 e Exon y CytoBand/Cytogenic i Intronic position r RNA position \u2714 n non-coding DNA reference sequence \u2714","title":"About"},{"location":"variant_notation/coordinate_systems/#about","text":"Notation forms will use a common prefix notation. These describe the units of any positions given in the variant description. For example, protein notation ( p. ) would have amino acids as units. Prefix Coordinate Type Standard HGVS g Genomic \u2714 c Coding reference sequence (CDS) \u2714 p Protein \u2714 e Exon y CytoBand/Cytogenic i Intronic position r RNA position \u2714 n non-coding DNA reference sequence \u2714","title":"About"},{"location":"variant_notation/coordinate_systems/cytoband/","text":"CytoBand Coordinates CytoBand notation is included in GraphKB-HGVS to increase compatibility with variant notation in older publications and knowledgebases. CytoBand coordinates ( y ) are not a feature of HGVS, however variants using this system follow much the same patterns as the other types. Since this coordinate system is not very specific, the types of variants one can describe is more limited. Generally only duplications/gains, deletions/losses, inversions, and translocations can be described. Additionally sequence is never included. Any position in the CytoBand coordinate system is described by the pattern <arm><majorBand>.<minorBand> The minor band number is optional. Deletion Example A deletion spanning p11.1 to p12. chr1:y.p11.1_p12del","title":"CytoBand Coordinates"},{"location":"variant_notation/coordinate_systems/cytoband/#cytoband-coordinates","text":"CytoBand notation is included in GraphKB-HGVS to increase compatibility with variant notation in older publications and knowledgebases. CytoBand coordinates ( y ) are not a feature of HGVS, however variants using this system follow much the same patterns as the other types. Since this coordinate system is not very specific, the types of variants one can describe is more limited. Generally only duplications/gains, deletions/losses, inversions, and translocations can be described. Additionally sequence is never included. Any position in the CytoBand coordinate system is described by the pattern <arm><majorBand>.<minorBand> The minor band number is optional.","title":"CytoBand Coordinates"},{"location":"variant_notation/coordinate_systems/cytoband/#deletion-example","text":"A deletion spanning p11.1 to p12. chr1:y.p11.1_p12del","title":"Deletion Example"}]}